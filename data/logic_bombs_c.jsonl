{"index": 0, "logic_bombs_task_id": "ln_ef_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include <string.h> \n#include <math.h>\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    double d = log(symvar); \n    if(1.94 < d && d < 1.95){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 1, "logic_bombs_task_id": "sin_ef_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include <string.h> \n#include <math.h>\n\n#define PI 3.14159265358979323846264338327\n\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0];\n    float v = sin(symvar*PI/30);\n    if(v > 0.5){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 2, "logic_bombs_task_id": "atoi_ef_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include <string.h> \n#include <math.h>\n\n\nint logic_bomb(char* symvar) {\n    int i = atoi(symvar);\n    if(i==7){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 3, "logic_bombs_task_id": "printint_int_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include <string.h> \n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int x = symvar + 190;\n    printf(\"x = %d\\n\", x);\n    if(x == 197){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 4, "logic_bombs_task_id": "atof_ef_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include <string.h> \n#include <math.h>\n\n\nint logic_bomb(char* symvar) {\n    float i = atof(symvar);\n    if(i - 7 == 0){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 5, "logic_bombs_task_id": "printfloat_ef_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include <string.h> \n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    float x = symvar + 190;\n    printf(\"x = %f\\n\", x);\n    if(x - 197 == 0){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 6, "logic_bombs_task_id": "rand_ef_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include <string.h> \n\n\nint logic_bomb(char* s) {\n    int symvar = s[0];\n    srand(symvar);\n    int r = rand()%100;\n    if(r == 77){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 7, "logic_bombs_task_id": "pow_ef_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include <string.h> \n#include <math.h>\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    if(pow(symvar, 2) == 49){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 8, "logic_bombs_task_id": "jmp_sj_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <stdio.h>\n\n#define jmp(addr) asm(\"jmp *%0\"::\"r\"(addr):)\n\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    if (symvar%6 != 1 || symvar < 10|| symvar > 40 || symvar == 19)\n\tsymvar = 13;\n    long long addr = &&flag_0 + symvar;\n    jmp(addr);\n  flag_0:\n    if (symvar > 0){\n        symvar++;\n        if(symvar == 0)\n            return 1;\n    }\n    return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 9, "logic_bombs_task_id": "arrayjmp_sj_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <stdio.h>\n\n#define jmp(addr) asm(\"jmp *%0\"::\"r\"(addr):)\n\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int array[] = {7,13,14,15,16,21,22,37,23,24};\n    long long addr = &&flag_0 + array[symvar%10];\n    jmp(addr);\n  flag_0:\n    if (symvar > 0){\n        symvar++;\n        if(symvar == 0)\n            return 1;\n    }\n    return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 10, "logic_bombs_task_id": "pointers_sj_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <stdio.h>\n\n\nint func0(){return 0;}\nint func1(){return 1;}\nint func2(){return 2;}\nint func3(){return 3;}\nint func4(){return 4;}\nint func5(){return 5;}\nint func6(){return 6;}\n\n\nint logic_bomb(char* s) {\n    int (*f[7])() = {func0, func1, func2, func3, func4, func5, func6};\n    int symvar = s[0] - 48;\n    int ret = f[symvar%7](); \n    printf (\"ret = %d\\n\", ret);\n    if (ret == 5){\n        return 1;\n    }\n    return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 11, "logic_bombs_task_id": "stackoutofbound_sm_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <stdio.h>\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int a[] = {1, 2, 3, 4, 5, 6};\n    if (a[symvar]<0 || a[symvar] > 6){\n        return 1;\n    }\n    return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 12, "logic_bombs_task_id": "stackarray_sm_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include<stdio.h>\n\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int l1_ary[] ={1,2,3,4,5}; \n    int l2_ary[] ={6,7,8,9,10}; \n\n    int x = symvar%5;\n    if(l2_ary[l1_ary[x]] == 9){\n        return 1;\n     }\n    else\n        return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 13, "logic_bombs_task_id": "heapoutofbound_sm_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<stdlib.h>\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int *array = (int *) malloc(sizeof(int) * 10);\n    int k = 0;\n    for (k=0; k<10; k++){\n\tarray[k] = k;\n    }\n    if(array[symvar]<0 || array[symvar]>10){\n       return 1;\n    }\n    return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 14, "logic_bombs_task_id": "stackarray_sm_ln", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include<stdio.h>\n\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int i = symvar;\n    int j = abs(i%11);\n    int a[] = {(i+5)%11,(i+6)%11,(i+7)%11,(i+8)%11,(i+9)%11,(i+10)%11,i%11,(i+1)%11,(i+2)%11,(i+3)%11,(i+4)%11};\n    int* p = &a[a[a[j]]];\n    int* q = &a[a[a[a[a[*p]]]]];\n\n    if(p == q){\n        return 1;\n     }\n    else\n        return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 15, "logic_bombs_task_id": "malloc_sm_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<stdlib.h>\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int *array = (int *) malloc(sizeof(int) * 10);\n    int k = 0;\n    for (k=0; k<10; k++){\n\tarray[k] = k;\n    }\n    if(array[symvar % 10] == 7){\n       return 1;\n    }\n    return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 16, "logic_bombs_task_id": "realloc_sm_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<stdlib.h>\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int *array = (int *) malloc(sizeof(int) * 5);\n    int k = 0;\n    for (k=0; k<5; k++){\n        array[k] = k;\n    }\n    array = (int *) realloc (array, sizeof(int) * 10);\n    for (k=5; k<10; k++){\n        array[k] = k;\n    }\n    if(array[symvar%10] == 7){\n        return 1;\n    }\n    return 0;\n}\n\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 17, "logic_bombs_task_id": "stackarray_sm_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int ary[] ={1,2,3,4,5};\n    if(ary[symvar%5] == 5){\n        return 1;\n     }\n    else\n\treturn 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 18, "logic_bombs_task_id": "aes_cf", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include <inttypes.h>\n#include \"aes.h\"\n\nvoid aes_print(uint8_t* str) {\n    unsigned char i;\n    for(i = 0; i < 16; ++i)\n        printf(\"%.2x\", str[i]);\n    printf(\"\\n\");\n}\n\n\n\nint logic_bomb(char* s) {\n    if(strlen(s) != 32){\n        \n\treturn 0;\n    }\n\n    uint8_t key[16];\n\n    sscanf(s,\n        \"%2\" SCNx8 \"%2\" SCNx8\n        \"%2\" SCNx8 \"%2\" SCNx8\n        \"%2\" SCNx8 \"%2\" SCNx8\n        \"%2\" SCNx8 \"%2\" SCNx8\n    \t\"%2\" SCNx8 \"%2\" SCNx8\n    \t\"%2\" SCNx8 \"%2\" SCNx8\n   \t\"%2\" SCNx8 \"%2\" SCNx8\n    \t\"%2\" SCNx8 \"%2\" SCNx8,\n    \t&key[0],&key[1],\n    \t&key[2],&key[3],\n    \t&key[4],&key[5],\n    \t&key[6],&key[7],\n    \t&key[8],&key[9],\n    \t&key[10],&key[11],\n    \t&key[12],&key[13],\n    \t&key[14],&key[15]);\n\n    \n\n    uint8_t decodetext[16];\n    uint8_t ciphertext[] = {0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97};\n    uint8_t plaintext[] = {0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a};\n\n    AES128_ECB_decrypt(ciphertext, key, decodetext);\n\n    \n    if(0 == memcmp((char*) plaintext, (char*) decodetext, 16)){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 19, "logic_bombs_task_id": "sha_cf", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include \"sha1.h\"\n\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int plaintext = symvar;\n    unsigned cipher[5];\n    cipher[0] = 0X902ba3cd;\n    cipher[1] = 0Xa1883801;\n    cipher[2] = 0X594b6e1b;\n    cipher[3] = 0X452790cc;\n    cipher[4] = 0X53948fda;\n\n    if(SHA1_COMP(plaintext,cipher)==0){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 20, "logic_bombs_task_id": "df2cf_cp_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include <string.h> \n\n\nint df2cf(char a)\n{\n    int b;\n    switch(a){\n      case 0:\n        b = 0;\n\tbreak;\n      case 1:\n        b = 1;\n\tbreak;\n      case 2:\n        b = 2;\n\tbreak;\n      case 3:\n        b = 3;\n\tbreak;\n      case 4:\n        b = 4;\n\tbreak;\n      case 5:\n        b = 5;\n\tbreak;\n      case 6:\n        b = 6;\n\tbreak;\n      case 7:\n        b = 7;\n\tbreak;\n      case 8:\n        b = 8;\n\tbreak;\n      case 9:\n        b = 9;\n\tbreak;\n      default:\n        b = 0;\n        break;\n    }\n    return b;\n}\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int a = df2cf(symvar%10);\n    a++;\n    int b = symvar + a;\n    if(b == 15)\n        return 1;\n    else\n        return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 21, "logic_bombs_task_id": "stack_cp_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int j;\n    __asm__ __volatile__(\"push %0\" :: \"m\"(symvar));\n    __asm__ __volatile__(\"pop %0\" :: \"m\"(j));\n    if(j == 7){\n        return 1;\n    } else{\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 22, "logic_bombs_task_id": "echofile_cp_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include <string.h> \n\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int j;\n    char file[] = \"tmp.covpro\";\n    char cmd[256];\n    sprintf(cmd, \"echo %d > %s\\n\", symvar, file); \n    system(cmd);\n\n    FILE *fp = stdin;\n    fp = fopen(file, \"r\");\n    fscanf(fp,\"%d\",&j);\n    fclose(fp);\n    remove(file);\n\n    if(j == 7){\n        return 1;\n    } else{\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 23, "logic_bombs_task_id": "echo_cp_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <string.h> \n\n\nchar* shell(const char* cmd)\n{\n    char* rs = \"\";\n    FILE *f;\n    f = popen(cmd, \"r\");\n    char buf[1024];\n    memset(buf,'\\0',sizeof(buf));\n    while(fgets(buf,1024-1,f)!=NULL)\n    { \n       rs = buf;\n    }\n\n    pclose(f);\n    return rs;\n}\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    char cmd[256];\n    sprintf(cmd, \"echo %d\\n\", symvar); \n    char* rs = shell(cmd);\n\n   if(atoi(rs) == 7)\n    return 1;\n   else\n    return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 24, "logic_bombs_task_id": "file_cp_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include <string.h> \n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int j;\n    char file[] = \"tmp.covpro\";\n    FILE *fp = fopen(file, \"ab+\");\n    if(fp == NULL)\n    {\n        \n        exit(1);             \n    }\n    fprintf(fp,\"%d\",symvar);\n    fclose(fp);\n\n    fp = fopen(\"tmp.covpro\", \"r\");\n    fscanf(fp,\"%d\",&j);\n    fclose(fp);\n    remove(file);\n    if(j == 7){\n        return 1;\n    } else{\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 25, "logic_bombs_task_id": "file_posix_cp_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <string.h>\n\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int j;\n    char file[] = \"tmp.covpro\";\n    int fd = open(file, O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR);\n    if(fd < 0)\n    {\n        exit(-1);             \n    }\n    write(fd, &symvar, sizeof symvar);\n    close(fd);\n    fd = open(file, O_RDONLY);\n    read(fd, &j, sizeof j);\n    close(fd);\n    if(j == 7){\n        return 1;\n    } else{\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 26, "logic_bombs_task_id": "socket_cp_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include <unistd.h>\n\nint server(){\n    int server_sockfd,client_sockfd;\n    int server_len,client_len;\n    struct sockaddr_in server_address;\n    struct sockaddr_in client_address;\n    int i,btye;\n    char char_recv,char_send;\n\n    server_address.sin_family = AF_INET;\n    server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    server_address.sin_port = 19991;\n    server_len = sizeof(server_address);\n\n    server_sockfd = socket(AF_INET,SOCK_STREAM,0);\n\n    bind(server_sockfd,(struct sockaddr *)&server_address,server_len);\n\n    listen(server_sockfd,5);\n    \n\n    client_len = sizeof(client_address);\n    client_sockfd = accept(server_sockfd,(struct sockaddr *)&client_address,(socklen_t *)&client_len);\n\n    if(btye = recv(client_sockfd,&char_recv,1,0) == -1) {\n        perror(\"recv\");\n        exit(EXIT_FAILURE);\n    }\n    \n\n    char_send = char_recv;\n    if(btye = send(client_sockfd,&char_send,1,0) == -1) {\n        perror(\"send\");\n        exit(EXIT_FAILURE);\n    }\n\n    close(client_sockfd);\n    close(server_sockfd);\n}\n\nint client_send(char char_send){\n    \n    int sockfd;\n    int len;\n    struct sockaddr_in address;\n    int result;\n    int i,byte;\n    char char_recv;\n    if((sockfd = socket(AF_INET,SOCK_STREAM,0)) == -1) {\n        perror(\"socket\");\n        exit(-1);\n    }\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    address.sin_port = 19991;\n    len = sizeof(address);\n    if((result = connect(sockfd,(struct sockaddr *)&address,len)) == -1) {\n        perror(\"connect\");\n        exit(-1);\n    }\n\n    if(byte = send(sockfd,&char_send,1,0) == -1) {\n        perror(\"send\");\n        exit(-1);\n    }\n    if(byte = recv(sockfd,&char_recv,1,0) == -1) {\n        perror(\"recv\");\n        exit(-1);\n    }\n    \n    int ret = char_recv - 48;\n    close(sockfd);\n    return ret;\n}\n\n\nint logic_bomb(char* s) {\n    int pid1,status,i=0;\n    pid1=fork();\n    if(pid1 < 0){\n    return 0;\n    }\n    else if(pid1 == 0){\n        server();\n        waitpid(NULL);\n        exit(0);\n    }else{\n        sleep(5);\n        i=client_send(s[0]);\n        if(i == 7){\n            return 1;\n         }else{\n            return 0;\n         }\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 27, "logic_bombs_task_id": "pid_csv", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n\n\nint logic_bomb(char* s) {\n   int symvar = s[0] - 48;\n   int pid = (int) getpid();\n   if(pid%78 == symvar)\n    return 1;\n   else\n    return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 28, "logic_bombs_task_id": "syscall_csv", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n#include <string.h>\n\n\n\nint logic_bomb(char* s) {\n    if(s == NULL)\n\treturn 0;\n    if(s[0]=='\\0')\n\treturn 0;\n    int trigger = -1;\n    trigger = system(s);\n    if(trigger == 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 29, "logic_bombs_task_id": "file_posix_csv", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <string.h> \n\n\n\nint logic_bomb(char* s) {\n    int trigger = 0;\n    int fd = open(s, O_RDONLY);\n    if(fd != -1) {\n    \ttrigger = 1;\n        close(fd);\n    }\n\n    if(trigger) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 30, "logic_bombs_task_id": "file_csv", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <string.h> \n\n\n\nint logic_bomb(char* s) {\n    int trigger = 0;\n    FILE *fp = fopen(s, \"r\");\n    if(fp != NULL) {\n\ttrigger = 1;\n        fclose(fp);\n    }\n\n    if(trigger) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 31, "logic_bombs_task_id": "ping_csv", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/ip_icmp.h>\n#include <arpa/inet.h>\n#include <sys/select.h>\n\n\nint ping_it(struct in_addr *dst)\n{\n    struct icmphdr icmp_hdr;\n    struct sockaddr_in addr;\n    int sequence = 0;\n    int sock = socket(AF_INET,SOCK_DGRAM,IPPROTO_ICMP);\n    if (sock < 0) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    memset(&addr, 0, sizeof addr);\n    addr.sin_family = AF_INET;\n    addr.sin_addr = *dst;\n\n    memset(&icmp_hdr, 0, sizeof icmp_hdr);\n    icmp_hdr.type = ICMP_ECHO;\n    icmp_hdr.un.echo.id = 1234;\n\n    unsigned char data[2048];\n    int rc;\n    struct timeval timeout = {1, 0}; \n    fd_set read_set;\n    socklen_t slen;\n    struct icmphdr rcv_hdr;\n\n    icmp_hdr.un.echo.sequence = sequence++;\n    memcpy(data, &icmp_hdr, sizeof icmp_hdr);\n    memcpy(data + sizeof icmp_hdr, \"hello\", 5); \n    rc = sendto(sock, data, sizeof icmp_hdr + 5,\n                    0, (struct sockaddr*)&addr, sizeof addr);\n    if (rc <= 0) {\n        perror(\"Sendto\");\n    }\n    puts(\"Sent ICMP\\n\");\n\n    memset(&read_set, 0, sizeof read_set);\n    FD_SET(sock, &read_set);\n\n    \n    rc = select(sock + 1, &read_set, NULL, NULL, &timeout);\n    if (rc == 0) {\n        puts(\"Got no reply\\n\");\n    \treturn 0;\n    } else if (rc < 0) {\n        perror(\"Select\");\n    \treturn 0;\n    }\n\n    \n    slen = 0;\n    rc = recvfrom(sock, data, sizeof data, 0, NULL, &slen);\n    if (rc <= 0) {\n        perror(\"recvfrom\");\n    } else if (rc < sizeof rcv_hdr) {\n        \n    }\n    memcpy(&rcv_hdr, data, sizeof rcv_hdr);\n    if (rcv_hdr.type == ICMP_ECHOREPLY) {\n        \n                        \n    } else {\n        \n    }\n    return 1;\n}\n\n\n\nint logic_bomb(char* s) {\n    struct in_addr dst;\n\n    if (inet_aton(s, &dst) == 0) {\n        perror(\"inet_aton\");\n        \n        return 0;\n    }\n\n    if (ping_it(&dst) == 1){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 32, "logic_bombs_task_id": "addint_to_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    if (symvar + 2147483640 < 0 && symvar > 0)\n        return 1;\n    else\n        return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 33, "logic_bombs_task_id": "multiplyint_to_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    if (254748364 * symvar < 0 && symvar > 0)\n        return 1;\n    else\n        return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 34, "logic_bombs_task_id": "7n+1_lo_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <string.h> \n\nlong f(long x){\n    if (x%2 == 0)\n\treturn x/2;\n    else if (x%3 == 0)\n\treturn x/3;\n    else if (x%5 == 0)\n\treturn x/5;\n    else\n        return 7*x + 1;\n}\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    symvar = symvar + 1104;\n    long j = f(symvar);\n    int loopcount = 1;\n    while(j != 1){\n\tj = f(j);\n        loopcount ++;\n    }\n    if(loopcount == 50)\n        return 1;\n    else\n        return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 35, "logic_bombs_task_id": "5n+1_lo_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <string.h> \n\nlong f(long x){\n    if (x%2 == 0)\n\treturn x/2;\n    else if (x%3 == 0)\n\treturn x/3;\n    else\n        return 3*x + 1;\n}\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    symvar = symvar + 94;\n    long j = f(symvar);\n    int loopcount = 1;\n    while(j != 1){\n\tj = f(j);\n        loopcount ++;\n    }\n    if(loopcount == 25)\n        return 1;\n    else\n        return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 36, "logic_bombs_task_id": "collaz_lo_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <string.h> \n\nlong f(long x){\n    if (x%2 == 0)\n\treturn x/2;\n    return 3*x + 1;\n}\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    symvar = symvar + 670617272;\n    if(symvar>999999999)\n\treturn 0;\n    long j = f(symvar);\n    int loopcount = 1;\n    while(j != 1){\n\tj = f(j);\n        loopcount ++;\n    }\n    if(loopcount == 986)\n        return 1;\n    else\n        return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 37, "logic_bombs_task_id": "paraloop_lo_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <pthread.h>\n#include <time.h>\n#include <unistd.h>\n\nvoid* trigger(void* i){\n    sleep(5);\n    ++ *((int*) i);\n}\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int i = symvar + 1;\n    pthread_t tid;\n    int rc = pthread_create(&tid, NULL, trigger, (void *) &symvar); \n    while (symvar != i){\n\tsleep(1);\n        symvar ++;\n        i ++;\n    }\n    rc = pthread_join(tid, NULL); \n    if(symvar == 13)\n        return  1;\n    return  0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 38, "logic_bombs_task_id": "collaz_lo_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <string.h> \n\nint f(int x){\n    if (x%2 == 0)\n\treturn x/2;\n    return 3*x + 1;\n}\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    symvar = symvar + 94;\n    int j = f(symvar);\n    int loopcount = 1;\n    while(j != 1){\n\tj = f(j);\n        loopcount ++;\n    }\n    if(loopcount == 25)\n        return 1;\n    else\n        return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 39, "logic_bombs_task_id": "stack_bo_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <string.h> \n\n\n\nint logic_bomb(char* symvar) {\n    int flag = 0;\n    char buf[8];\n    strcpy(buf, symvar);\n    if(flag == 1){\n        return 1;\n    }\n    return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 40, "logic_bombs_task_id": "heap_bo_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <string.h> \n\nint n = 5;\n\n\nint logic_bomb(char* symvar) {\n    char *p, *q;\n    p = (char*)malloc(16);\n    q = (char*)malloc(16);\n    strcpy(p, symvar);\n    free(q);\n    if (n != 5){\n        free(p);\n        return 1;\n    }else {\n        free(p);\n        return 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 41, "logic_bombs_task_id": "stack_bo_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <string.h> \n\nint trigger(){\n    return 1;\n}\n\n\nint logic_bomb(char* symvar) {\n    char buf[8];\n    strcpy(buf, symvar);\n    if(buf < 0)\n        return trigger();\n    return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 42, "logic_bombs_task_id": "stacknocrash_bo_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <string.h> \n\n\n\nint logic_bomb(char* symvar) {\n    int flag = 0;\n    char buf[8];\n    if(strlen(symvar) > 9)\n        return 0;\n    strcpy(buf, symvar);\n    if(flag == 1){\n        return 1;\n    }\n    return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 43, "logic_bombs_task_id": "2thread_pp_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <pthread.h>\n#include <time.h>\n#include <unistd.h>\n\nvoid* Inc(void* i){\n    int count = 0;\n    while (*((int *) i) > -1000 && count++ < 1000){\n\t++ *((int *) i);\n        \n    }\n}\n\nvoid* Dec(void* i){\n    int count = 0;\n    while (*((int *) i) <  1000 && count++ < 1000){\n\t-- *((int *) i);\n        \n    }\n}\n\nint ThreadProp(int in){\n    pthread_t tid[2];\n    pthread_create(&tid[0], NULL, Inc, (void *) &in); \n    pthread_create(&tid[1], NULL, Dec, (void *) &in); \n    pthread_join(tid[0], NULL); \n    pthread_join(tid[1], NULL); \n    return in;\n}\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int i=ThreadProp(symvar-909);\n    \n    if(i == -1900)\n        return  1;\n    return  0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 44, "logic_bombs_task_id": "forkshm_pp_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/shm.h>\n#include <sys/ipc.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n\nint logic_bomb(char* symvar) {\n    char *p_addr, *c_addr;\n    int flag = 0;\n    key_t shmid = shmget(IPC_PRIVATE, 1024, S_IRUSR|S_IWUSR);\n    if (shmid < 0)\n\treturn 0;\n    pid_t pid = fork();\n    if(pid == 0){\n\tp_addr = shmat(shmid,0,0);\n        memset(p_addr,'/0',1024);\n        strncpy(p_addr, symvar, 1024);\n\texit(0);\n    }\n    if (pid > 0){\n\tsleep(1);\n        c_addr = shmat(shmid,0,0);\n        if(strcmp(c_addr, \"7\") == 0)\n\t    flag = 1;\n        shmctl(shmid,IPC_RMID,0);\n        if(flag == 1)\n\t    return 1;\n\treturn 0;\n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 45, "logic_bombs_task_id": "2thread_pp_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <pthread.h>\n#include <time.h>\n#include <unistd.h>\n\nvoid* Inc(void* i){\n\t++ *((int*) i);\n}\n\nvoid* Mult(void* i){\n\t*((int*) i) =  *((int*) i) * *((int*) i);\n}\n\nint ThreadProp(int in){\n\tpthread_t tid[2];\n\tint rc1 = pthread_create(&tid[0], NULL, Inc, (void *) &in); \n\tint rc2 = pthread_create(&tid[1], NULL, Mult, (void *) &in); \n\trc1 = pthread_join(tid[0], NULL); \n\trc2 = pthread_join(tid[1], NULL); \n\tint out = in;\n\treturn out;\n}\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int i=ThreadProp(symvar);\n    if(i == 50)\n        return  1;\n    return  0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 46, "logic_bombs_task_id": "mthread_pp_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <pthread.h>\n#include <time.h>\n#include <unistd.h>\n\nvoid* Inc(void* i){\n    int count = 0;\n    while (*((int *) i) > -1000 && count++ < 1000){\n\t++ *((int*) i);\n    }\n}\n\nvoid* Dec(void* i){\n    int count = 0;\n    while (*((int *) i) < 1000 && count++ < 1000){\n\t-- *((int*) i);\n    }\n}\n\nint ThreadProp(int in){\n    pthread_t tid[10];\n    pthread_create(&tid[0], NULL, Inc, (void *) &in); \n    pthread_create(&tid[1], NULL, Dec, (void *) &in); \n    pthread_create(&tid[2], NULL, Inc, (void *) &in); \n    pthread_create(&tid[3], NULL, Dec, (void *) &in); \n    pthread_create(&tid[4], NULL, Inc, (void *) &in); \n    pthread_create(&tid[5], NULL, Dec, (void *) &in); \n    pthread_create(&tid[6], NULL, Inc, (void *) &in); \n    pthread_create(&tid[7], NULL, Dec, (void *) &in); \n    pthread_create(&tid[8], NULL, Inc, (void *) &in); \n    pthread_create(&tid[9], NULL, Dec, (void *) &in); \n    pthread_join(tid[0], NULL); \n    pthread_join(tid[1], NULL); \n    pthread_join(tid[2], NULL); \n    pthread_join(tid[3], NULL); \n    pthread_join(tid[4], NULL); \n    pthread_join(tid[5], NULL); \n    pthread_join(tid[6], NULL); \n    pthread_join(tid[7], NULL); \n    pthread_join(tid[8], NULL); \n    pthread_join(tid[9], NULL); \n    return in;\n}\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    int i=ThreadProp(symvar+990);\n    \n    if(i == 5999)\n        return  1;\n    return  0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 47, "logic_bombs_task_id": "forkpipe_pp_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include <unistd.h>\n\n\nint logic_bomb(char* s) {\n    int pid, fd[2];\n    pipe(fd);\n    if ((pid = fork()) == -1)\n        return 0;\n    if (pid == 0) {\n        close(fd[0]);\n        write(fd[1], s, sizeof(s));\n        wait(NULL);\n\texit(0);\n    }\n    else {\n        char content[8];\n        close(fd[1]);\n        read(fd[0], content, 8);\n        if (strcmp(content, \"7\") == 0) {\n            return 1;\n        }\n        return 0; \n    }\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 48, "logic_bombs_task_id": "float4_fp_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include <stdlib.h>\n\n\nint logic_bomb(char* symvar) {\n    float x = atof(symvar);\n    x = x/-10000.0;\n    if(1024+x == 1024 && x>0)\n        return 1;\n    else\n        return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 49, "logic_bombs_task_id": "float3_fp_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include <stdlib.h>\n\n\nint logic_bomb(char* symvar) {\n    float x = atof(symvar);\n    x = x/10000.0;\n    if(1024+x == 1024 && x>0)\n        return 1;\n    else\n        return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 50, "logic_bombs_task_id": "float1_fp_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include <stdlib.h>\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    float a = symvar/70.0;\n    float b = 0.1;\n    if(a != 0.1){\n\tif(a - b == 0)\n            return 1;\n    }\n    return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 51, "logic_bombs_task_id": "float2_fp_l1", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include <stdlib.h>\n\n\nint logic_bomb(char* s) {\n    int symvar = s[0] - 48;\n    float x = symvar + 0.0000005;\n    if(x != 7){\n        float x = symvar + 1;\n        if (x == 8)\n            return 1;\n    }\n    return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
{"index": 52, "logic_bombs_task_id": "float5_fp_l2", "focal_method_name": "logic_bomb", "focal_method_para": "(char* s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include <stdlib.h>\n\n\nint logic_bomb(char* symvar) {\n    float x = atof(symvar);\n    x = x/10.0;\n    x = x + 0.1;\n    x = x * x;\n    if (x > 0.1)\n\tx -= x;\n    if(x != 0.02){\n        x = x + 7.98;\n        if(x == 8)\n            return 1;\n    }\n    return 0;\n}\n", "target": "#include \"assert.h\"\nint main(){\n\tassert(logic_bomb(<FILL_ME>) == 1);\n}"}
