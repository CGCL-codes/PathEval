{"index": 0, "humaneval_task_id": "CPP/0", "focal_method_name": "has_close_elements", "focal_method_para": "(vector<float> numbers, float threshold)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\n    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = has_close_elements(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 1, "humaneval_task_id": "CPP/0", "focal_method_name": "has_close_elements", "focal_method_para": "(vector<float> numbers, float threshold)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\n    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = has_close_elements(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 2, "humaneval_task_id": "CPP/1", "focal_method_name": "separate_paren_groups", "focal_method_para": "(string paren_string)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"(()(())((())))\"}));\n}"}
{"index": 3, "humaneval_task_id": "CPP/1", "focal_method_name": "separate_paren_groups", "focal_method_para": "(string paren_string)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"()\",\"(())\",\"((()))\",\"(((())))\"}));\n}"}
{"index": 4, "humaneval_task_id": "CPP/1", "focal_method_name": "separate_paren_groups", "focal_method_para": "(string paren_string)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"(()())\",\"((()))\",\"()\",\"((())()())\"}));\n}"}
{"index": 5, "humaneval_task_id": "CPP/1", "focal_method_name": "separate_paren_groups", "focal_method_para": "(string paren_string)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"()\",\"(())\",\"(()())\"}));\n}"}
{"index": 6, "humaneval_task_id": "CPP/2", "focal_method_name": "truncate_number", "focal_method_para": "(float number)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}", "target": "#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(abs(result-0.456)<1e-4);\n}"}
{"index": 7, "humaneval_task_id": "CPP/2", "focal_method_name": "truncate_number", "focal_method_para": "(float number)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}", "target": "#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(abs(result-0.33)<1e-4);\n}"}
{"index": 8, "humaneval_task_id": "CPP/2", "focal_method_name": "truncate_number", "focal_method_para": "(float number)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}", "target": "#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(result==0.5);\n}"}
{"index": 9, "humaneval_task_id": "CPP/3", "focal_method_name": "below_zero", "focal_method_para": "(vector<int> operations)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\n    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = below_zero(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 10, "humaneval_task_id": "CPP/3", "focal_method_name": "below_zero", "focal_method_para": "(vector<int> operations)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\n    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = below_zero(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 11, "humaneval_task_id": "CPP/4", "focal_method_name": "mean_absolute_deviation", "focal_method_para": "(vector<float> numbers)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat mean_absolute_deviation(vector<float> numbers){\n    float sum=0;\n    float avg,msum,mavg;\n    int i=0;\n    for (i=0;i<numbers.size();i++)\n        sum+=numbers[i];\n    avg=sum/numbers.size();\n    msum=0;\n    for (i=0;i<numbers.size();i++)\n        msum+=abs(numbers[i]-avg);\n    return msum/numbers.size();\n}", "target": "#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = mean_absolute_deviation(<FILL_ME>);\n\tassert(result<1e-4);\n}"}
{"index": 12, "humaneval_task_id": "CPP/5", "focal_method_name": "intersperse", "focal_method_para": "(vector<int> numbers, int delimeter)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{5,8,6,8,3,8,2}));\n}"}
{"index": 13, "humaneval_task_id": "CPP/5", "focal_method_name": "intersperse", "focal_method_para": "(vector<int> numbers, int delimeter)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{2,2,2,2,2}));\n}"}
{"index": 14, "humaneval_task_id": "CPP/5", "focal_method_name": "intersperse", "focal_method_para": "(vector<int> numbers, int delimeter)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 15, "humaneval_task_id": "CPP/6", "focal_method_name": "parse_nested_parens", "focal_method_para": "(string paren_string)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{2,3,1,3}));\n}"}
{"index": 16, "humaneval_task_id": "CPP/6", "focal_method_name": "parse_nested_parens", "focal_method_para": "(string paren_string)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}"}
{"index": 17, "humaneval_task_id": "CPP/6", "focal_method_name": "parse_nested_parens", "focal_method_para": "(string paren_string)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{4}));\n}"}
{"index": 18, "humaneval_task_id": "CPP/7", "focal_method_name": "filter_by_substring", "focal_method_para": "(vector<string> strings, string substring)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"}));\n}"}
{"index": 19, "humaneval_task_id": "CPP/7", "focal_method_name": "filter_by_substring", "focal_method_para": "(vector<string> strings, string substring)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"grunt\",\"prune\"}));\n}"}
{"index": 20, "humaneval_task_id": "CPP/7", "focal_method_name": "filter_by_substring", "focal_method_para": "(vector<string> strings, string substring)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}"}
{"index": 21, "humaneval_task_id": "CPP/7", "focal_method_name": "filter_by_substring", "focal_method_para": "(vector<string> strings, string substring)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 22, "humaneval_task_id": "CPP/8", "focal_method_name": "sum_product", "focal_method_para": "(vector<int> numbers)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{100,0}));\n}"}
{"index": 23, "humaneval_task_id": "CPP/8", "focal_method_name": "sum_product", "focal_method_para": "(vector<int> numbers)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}"}
{"index": 24, "humaneval_task_id": "CPP/8", "focal_method_name": "sum_product", "focal_method_para": "(vector<int> numbers)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{10,10}));\n}"}
{"index": 25, "humaneval_task_id": "CPP/8", "focal_method_name": "sum_product", "focal_method_para": "(vector<int> numbers)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{3,1}));\n}"}
{"index": 26, "humaneval_task_id": "CPP/8", "focal_method_name": "sum_product", "focal_method_para": "(vector<int> numbers)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{3+5+7,3*5*7}));\n}"}
{"index": 27, "humaneval_task_id": "CPP/9", "focal_method_name": "rolling_max", "focal_method_para": "(vector<int> numbers)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{3,3,3,100,100}));\n}"}
{"index": 28, "humaneval_task_id": "CPP/9", "focal_method_name": "rolling_max", "focal_method_para": "(vector<int> numbers)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{4,4,4,4}));\n}"}
{"index": 29, "humaneval_task_id": "CPP/9", "focal_method_name": "rolling_max", "focal_method_para": "(vector<int> numbers)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 30, "humaneval_task_id": "CPP/9", "focal_method_name": "rolling_max", "focal_method_para": "(vector<int> numbers)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}"}
{"index": 31, "humaneval_task_id": "CPP/11", "focal_method_name": "string_xor", "focal_method_para": "(string a,string b)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"0\");\n}"}
{"index": 32, "humaneval_task_id": "CPP/11", "focal_method_name": "string_xor", "focal_method_para": "(string a,string b)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"010010\");\n}"}
{"index": 33, "humaneval_task_id": "CPP/11", "focal_method_name": "string_xor", "focal_method_para": "(string a,string b)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"0101\");\n}"}
{"index": 34, "humaneval_task_id": "CPP/12", "focal_method_name": "longest", "focal_method_para": "(vector<string> strings)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"x\");\n}"}
{"index": 35, "humaneval_task_id": "CPP/12", "focal_method_name": "longest", "focal_method_para": "(vector<string> strings)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"\");\n}"}
{"index": 36, "humaneval_task_id": "CPP/12", "focal_method_name": "longest", "focal_method_para": "(vector<string> strings)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"zzzz\");\n}"}
{"index": 37, "humaneval_task_id": "CPP/13", "focal_method_name": "greatest_common_divisor", "focal_method_para": "(int a, int b)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==7);\n}"}
{"index": 38, "humaneval_task_id": "CPP/13", "focal_method_name": "greatest_common_divisor", "focal_method_para": "(int a, int b)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==12);\n}"}
{"index": 39, "humaneval_task_id": "CPP/13", "focal_method_name": "greatest_common_divisor", "focal_method_para": "(int a, int b)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 40, "humaneval_task_id": "CPP/13", "focal_method_name": "greatest_common_divisor", "focal_method_para": "(int a, int b)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==5);\n}"}
{"index": 41, "humaneval_task_id": "CPP/14", "focal_method_name": "all_prefixes", "focal_method_para": "(string str)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{\"W\",\"WW\",\"WWW\"}));\n}"}
{"index": 42, "humaneval_task_id": "CPP/14", "focal_method_name": "all_prefixes", "focal_method_para": "(string str)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 43, "humaneval_task_id": "CPP/14", "focal_method_name": "all_prefixes", "focal_method_para": "(string str)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"}));\n}"}
{"index": 44, "humaneval_task_id": "CPP/15", "focal_method_name": "string_sequence", "focal_method_para": "(int n)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"0\");\n}"}
{"index": 45, "humaneval_task_id": "CPP/15", "focal_method_name": "string_sequence", "focal_method_para": "(int n)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"0123\");\n}"}
{"index": 46, "humaneval_task_id": "CPP/15", "focal_method_name": "string_sequence", "focal_method_para": "(int n)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"012345678910\");\n}"}
{"index": 47, "humaneval_task_id": "CPP/16", "focal_method_name": "count_distinct_characters", "focal_method_para": "(string str)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 48, "humaneval_task_id": "CPP/16", "focal_method_name": "count_distinct_characters", "focal_method_para": "(string str)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 49, "humaneval_task_id": "CPP/16", "focal_method_name": "count_distinct_characters", "focal_method_para": "(string str)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==5);\n}"}
{"index": 50, "humaneval_task_id": "CPP/17", "focal_method_name": "parse_music", "focal_method_para": "(string music_string)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{4,4,4,4}));\n}"}
{"index": 51, "humaneval_task_id": "CPP/17", "focal_method_name": "parse_music", "focal_method_para": "(string music_string)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{2,2,1,1,4,4,4,4}));\n}"}
{"index": 52, "humaneval_task_id": "CPP/17", "focal_method_name": "parse_music", "focal_method_para": "(string music_string)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{1,1,1,1}));\n}"}
{"index": 53, "humaneval_task_id": "CPP/17", "focal_method_name": "parse_music", "focal_method_para": "(string music_string)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 54, "humaneval_task_id": "CPP/17", "focal_method_name": "parse_music", "focal_method_para": "(string music_string)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{2,1,2,1,4,2,4,2}));\n}"}
{"index": 55, "humaneval_task_id": "CPP/18", "focal_method_name": "how_many_times", "focal_method_para": "(string str,string substring)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 56, "humaneval_task_id": "CPP/18", "focal_method_name": "how_many_times", "focal_method_para": "(string str,string substring)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==4);\n}"}
{"index": 57, "humaneval_task_id": "CPP/18", "focal_method_name": "how_many_times", "focal_method_para": "(string str,string substring)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 58, "humaneval_task_id": "CPP/19", "focal_method_name": "sort_numbers", "focal_method_para": "(string numbers)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"zeroonetwothreefourfivesix\");\n}"}
{"index": 59, "humaneval_task_id": "CPP/19", "focal_method_name": "sort_numbers", "focal_method_para": "(string numbers)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"zerofourfiveseveneightnine\");\n}"}
{"index": 60, "humaneval_task_id": "CPP/19", "focal_method_name": "sort_numbers", "focal_method_para": "(string numbers)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"threefivenine\");\n}"}
{"index": 61, "humaneval_task_id": "CPP/19", "focal_method_name": "sort_numbers", "focal_method_para": "(string numbers)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"\");\n}"}
{"index": 62, "humaneval_task_id": "CPP/19", "focal_method_name": "sort_numbers", "focal_method_para": "(string numbers)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"three\");\n}"}
{"index": 63, "humaneval_task_id": "CPP/20", "focal_method_name": "find_closest_elements", "focal_method_para": "(vector<float> numbers)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{3.9,4.0}));\n}"}
{"index": 64, "humaneval_task_id": "CPP/20", "focal_method_name": "find_closest_elements", "focal_method_para": "(vector<float> numbers)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{5.0,5.9}));\n}"}
{"index": 65, "humaneval_task_id": "CPP/20", "focal_method_name": "find_closest_elements", "focal_method_para": "(vector<float> numbers)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.0,2.0}));\n}"}
{"index": 66, "humaneval_task_id": "CPP/20", "focal_method_name": "find_closest_elements", "focal_method_para": "(vector<float> numbers)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.0,2.2}));\n}"}
{"index": 67, "humaneval_task_id": "CPP/20", "focal_method_name": "find_closest_elements", "focal_method_para": "(vector<float> numbers)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.2,3.1}));\n}"}
{"index": 68, "humaneval_task_id": "CPP/21", "focal_method_name": "rescale_to_unit", "focal_method_para": "(vector<float> numbers)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.0,0.25,0.5,0.75,1.0}));\n}"}
{"index": 69, "humaneval_task_id": "CPP/21", "focal_method_name": "rescale_to_unit", "focal_method_para": "(vector<float> numbers)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.25,0.0,1.0,0.5,0.75}));\n}"}
{"index": 70, "humaneval_task_id": "CPP/21", "focal_method_name": "rescale_to_unit", "focal_method_para": "(vector<float> numbers)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.0,1.0}));\n}"}
{"index": 71, "humaneval_task_id": "CPP/21", "focal_method_name": "rescale_to_unit", "focal_method_para": "(vector<float> numbers)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{1.0,0.0}));\n}"}
{"index": 72, "humaneval_task_id": "CPP/22", "focal_method_name": "filter_integers", "focal_method_para": "(list_any values)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{4,9}));\n}"}
{"index": 73, "humaneval_task_id": "CPP/22", "focal_method_name": "filter_integers", "focal_method_para": "(list_any values)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 74, "humaneval_task_id": "CPP/22", "focal_method_name": "filter_integers", "focal_method_para": "(list_any values)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{3,3,3}));\n}"}
{"index": 75, "humaneval_task_id": "CPP/23", "focal_method_name": "strlen", "focal_method_para": "(string str)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==9);\n}"}
{"index": 76, "humaneval_task_id": "CPP/23", "focal_method_name": "strlen", "focal_method_para": "(string str)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 77, "humaneval_task_id": "CPP/23", "focal_method_name": "strlen", "focal_method_para": "(string str)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 78, "humaneval_task_id": "CPP/24", "focal_method_name": "largest_divisor", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==7);\n}"}
{"index": 79, "humaneval_task_id": "CPP/24", "focal_method_name": "largest_divisor", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 80, "humaneval_task_id": "CPP/24", "focal_method_name": "largest_divisor", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==5);\n}"}
{"index": 81, "humaneval_task_id": "CPP/24", "focal_method_name": "largest_divisor", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==50);\n}"}
{"index": 82, "humaneval_task_id": "CPP/25", "focal_method_name": "factorize", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,3,19,19}));\n}"}
{"index": 83, "humaneval_task_id": "CPP/25", "focal_method_name": "factorize", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,3,3}));\n}"}
{"index": 84, "humaneval_task_id": "CPP/25", "focal_method_name": "factorize", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2}));\n}"}
{"index": 85, "humaneval_task_id": "CPP/25", "focal_method_name": "factorize", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,2,2}));\n}"}
{"index": 86, "humaneval_task_id": "CPP/25", "focal_method_name": "factorize", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,19}));\n}"}
{"index": 87, "humaneval_task_id": "CPP/25", "focal_method_name": "factorize", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}"}
{"index": 88, "humaneval_task_id": "CPP/25", "focal_method_name": "factorize", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,19,19,19}));\n}"}
{"index": 89, "humaneval_task_id": "CPP/25", "focal_method_name": "factorize", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,3,3,19,19,19}));\n}"}
{"index": 90, "humaneval_task_id": "CPP/26", "focal_method_name": "remove_duplicates", "focal_method_para": "(vector<int> numbers)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{1,4,5}));\n}"}
{"index": 91, "humaneval_task_id": "CPP/26", "focal_method_name": "remove_duplicates", "focal_method_para": "(vector<int> numbers)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 92, "humaneval_task_id": "CPP/26", "focal_method_name": "remove_duplicates", "focal_method_para": "(vector<int> numbers)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}"}
{"index": 93, "humaneval_task_id": "CPP/27", "focal_method_name": "filp_case", "focal_method_para": "(string str)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"tHESEVIOLENTDELIGHTSHAVEVIOLENTENDS\");\n}"}
{"index": 94, "humaneval_task_id": "CPP/27", "focal_method_name": "filp_case", "focal_method_para": "(string str)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"hELLO!\");\n}"}
{"index": 95, "humaneval_task_id": "CPP/27", "focal_method_name": "filp_case", "focal_method_para": "(string str)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"\");\n}"}
{"index": 96, "humaneval_task_id": "CPP/28", "focal_method_name": "concatenate", "focal_method_para": "(vector<string> strings)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"xyzwk\");\n}"}
{"index": 97, "humaneval_task_id": "CPP/28", "focal_method_name": "concatenate", "focal_method_para": "(vector<string> strings)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"xyz\");\n}"}
{"index": 98, "humaneval_task_id": "CPP/28", "focal_method_name": "concatenate", "focal_method_para": "(vector<string> strings)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"\");\n}"}
{"index": 99, "humaneval_task_id": "CPP/29", "focal_method_name": "filter_by_prefix", "focal_method_para": "(vector<string> strings, string prefix)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = filter_by_prefix(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}"}
{"index": 100, "humaneval_task_id": "CPP/29", "focal_method_name": "filter_by_prefix", "focal_method_para": "(vector<string> strings, string prefix)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = filter_by_prefix(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 101, "humaneval_task_id": "CPP/30", "focal_method_name": "get_positive", "focal_method_para": "(vector<float> l)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{4,5,6}));\n}"}
{"index": 102, "humaneval_task_id": "CPP/30", "focal_method_name": "get_positive", "focal_method_para": "(vector<float> l)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{5,3,2,3,3,9,123,1}));\n}"}
{"index": 103, "humaneval_task_id": "CPP/30", "focal_method_name": "get_positive", "focal_method_para": "(vector<float> l)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 104, "humaneval_task_id": "CPP/31", "focal_method_name": "is_prime", "focal_method_para": "(long long n)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(long long n){\n    if (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_prime(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 105, "humaneval_task_id": "CPP/31", "focal_method_name": "is_prime", "focal_method_para": "(long long n)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(long long n){\n    if (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_prime(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 106, "humaneval_task_id": "CPP/33", "focal_method_name": "sort_third", "focal_method_para": "(vector<int> l)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,9,4,8,3,5}));\n}"}
{"index": 107, "humaneval_task_id": "CPP/33", "focal_method_name": "sort_third", "focal_method_para": "(vector<int> l)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,3,4,8,9,5}));\n}"}
{"index": 108, "humaneval_task_id": "CPP/33", "focal_method_name": "sort_third", "focal_method_para": "(vector<int> l)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,3,4,8,9,5,1}));\n}"}
{"index": 109, "humaneval_task_id": "CPP/33", "focal_method_name": "sort_third", "focal_method_para": "(vector<int> l)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,result));\n}"}
{"index": 110, "humaneval_task_id": "CPP/33", "focal_method_name": "sort_third", "focal_method_para": "(vector<int> l)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,8,3,4,6,9,5}));\n}"}
{"index": 111, "humaneval_task_id": "CPP/34", "focal_method_name": "unique", "focal_method_para": "(vector<int> l)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique(vector<int> l){\n    vector<int> out={};\n    for (int i=0;i<l.size();i++)\n        if (find(out.begin(),out.end(),l[i])==out.end())\n            out.push_back(l[i]);\n    sort(out.begin(),out.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = unique(<FILL_ME>);\n\tassert(issame(result,{0,2,3,5,9,123}));\n}"}
{"index": 112, "humaneval_task_id": "CPP/35", "focal_method_name": "max_element", "focal_method_para": "(vector<float> l)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = max_element(<FILL_ME>);\n\tassert(abs(result-124)<1e-4);\n}"}
{"index": 113, "humaneval_task_id": "CPP/35", "focal_method_name": "max_element", "focal_method_para": "(vector<float> l)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = max_element(<FILL_ME>);\n\tassert(abs(result-3)<1e-4);\n}"}
{"index": 114, "humaneval_task_id": "CPP/36", "focal_method_name": "fizz_buzz", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 115, "humaneval_task_id": "CPP/36", "focal_method_name": "fizz_buzz", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==639);\n}"}
{"index": 116, "humaneval_task_id": "CPP/36", "focal_method_name": "fizz_buzz", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==8026);\n}"}
{"index": 117, "humaneval_task_id": "CPP/36", "focal_method_name": "fizz_buzz", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==6);\n}"}
{"index": 118, "humaneval_task_id": "CPP/36", "focal_method_name": "fizz_buzz", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==192);\n}"}
{"index": 119, "humaneval_task_id": "CPP/36", "focal_method_name": "fizz_buzz", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==3);\n}"}
{"index": 120, "humaneval_task_id": "CPP/36", "focal_method_name": "fizz_buzz", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==2);\n}"}
{"index": 121, "humaneval_task_id": "CPP/37", "focal_method_name": "sort_even", "focal_method_para": "(vector<float> l)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{-10,3,-5,2,-3,3,5,0,9,1,123}));\n}"}
{"index": 122, "humaneval_task_id": "CPP/37", "focal_method_name": "sort_even", "focal_method_para": "(vector<float> l)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{-12,8,3,4,5,2,12,11,23,-10}));\n}"}
{"index": 123, "humaneval_task_id": "CPP/37", "focal_method_name": "sort_even", "focal_method_para": "(vector<float> l)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{1,2,3}));\n}"}
{"index": 124, "humaneval_task_id": "CPP/39", "focal_method_name": "prime_fib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==233);\n}"}
{"index": 125, "humaneval_task_id": "CPP/39", "focal_method_name": "prime_fib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==89);\n}"}
{"index": 126, "humaneval_task_id": "CPP/39", "focal_method_name": "prime_fib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==433494437);\n}"}
{"index": 127, "humaneval_task_id": "CPP/39", "focal_method_name": "prime_fib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==514229);\n}"}
{"index": 128, "humaneval_task_id": "CPP/39", "focal_method_name": "prime_fib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==28657);\n}"}
{"index": 129, "humaneval_task_id": "CPP/39", "focal_method_name": "prime_fib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==3);\n}"}
{"index": 130, "humaneval_task_id": "CPP/39", "focal_method_name": "prime_fib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==13);\n}"}
{"index": 131, "humaneval_task_id": "CPP/39", "focal_method_name": "prime_fib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==5);\n}"}
{"index": 132, "humaneval_task_id": "CPP/39", "focal_method_name": "prime_fib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==1597);\n}"}
{"index": 133, "humaneval_task_id": "CPP/39", "focal_method_name": "prime_fib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==2);\n}"}
{"index": 134, "humaneval_task_id": "CPP/40", "focal_method_name": "triples_sum_to_zero", "focal_method_para": "(vector<int> l)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool triples_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = triples_sum_to_zero(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 135, "humaneval_task_id": "CPP/40", "focal_method_name": "triples_sum_to_zero", "focal_method_para": "(vector<int> l)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool triples_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = triples_sum_to_zero(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 136, "humaneval_task_id": "CPP/41", "focal_method_name": "car_race_collision", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==16);\n}"}
{"index": 137, "humaneval_task_id": "CPP/41", "focal_method_name": "car_race_collision", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==4);\n}"}
{"index": 138, "humaneval_task_id": "CPP/41", "focal_method_name": "car_race_collision", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==100);\n}"}
{"index": 139, "humaneval_task_id": "CPP/41", "focal_method_name": "car_race_collision", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==9);\n}"}
{"index": 140, "humaneval_task_id": "CPP/41", "focal_method_name": "car_race_collision", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==64);\n}"}
{"index": 141, "humaneval_task_id": "CPP/42", "focal_method_name": "incr_list", "focal_method_para": "(vector<int> l)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{6,3,6,3,4,4,10,1,124}));\n}"}
{"index": 142, "humaneval_task_id": "CPP/42", "focal_method_name": "incr_list", "focal_method_para": "(vector<int> l)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 143, "humaneval_task_id": "CPP/42", "focal_method_name": "incr_list", "focal_method_para": "(vector<int> l)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{4,3,2}));\n}"}
{"index": 144, "humaneval_task_id": "CPP/43", "focal_method_name": "pairs_sum_to_zero", "focal_method_para": "(vector<int> l)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool pairs_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = pairs_sum_to_zero(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 145, "humaneval_task_id": "CPP/43", "focal_method_name": "pairs_sum_to_zero", "focal_method_para": "(vector<int> l)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool pairs_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = pairs_sum_to_zero(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 146, "humaneval_task_id": "CPP/44", "focal_method_name": "change_base", "focal_method_para": "(int x,int base)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"22\");\n}"}
{"index": 147, "humaneval_task_id": "CPP/44", "focal_method_name": "change_base", "focal_method_para": "(int x,int base)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"10000\");\n}"}
{"index": 148, "humaneval_task_id": "CPP/44", "focal_method_name": "change_base", "focal_method_para": "(int x,int base)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"111\");\n}"}
{"index": 149, "humaneval_task_id": "CPP/44", "focal_method_name": "change_base", "focal_method_para": "(int x,int base)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"1000\");\n}"}
{"index": 150, "humaneval_task_id": "CPP/44", "focal_method_name": "change_base", "focal_method_para": "(int x,int base)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"100\");\n}"}
{"index": 151, "humaneval_task_id": "CPP/44", "focal_method_name": "change_base", "focal_method_para": "(int x,int base)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"11101010\");\n}"}
{"index": 152, "humaneval_task_id": "CPP/45", "focal_method_name": "triangle_area", "focal_method_para": "(float a,float h)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-7.5)<1e-4);\n}"}
{"index": 153, "humaneval_task_id": "CPP/45", "focal_method_name": "triangle_area", "focal_method_para": "(float a,float h)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-2.0)<1e-4);\n}"}
{"index": 154, "humaneval_task_id": "CPP/45", "focal_method_name": "triangle_area", "focal_method_para": "(float a,float h)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-40.0)<1e-4);\n}"}
{"index": 155, "humaneval_task_id": "CPP/46", "focal_method_name": "fib4", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==104);\n}"}
{"index": 156, "humaneval_task_id": "CPP/46", "focal_method_name": "fib4", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==28);\n}"}
{"index": 157, "humaneval_task_id": "CPP/46", "focal_method_name": "fib4", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==386);\n}"}
{"index": 158, "humaneval_task_id": "CPP/46", "focal_method_name": "fib4", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==4);\n}"}
{"index": 159, "humaneval_task_id": "CPP/47", "focal_method_name": "median", "focal_method_para": "(vector<float> l)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-5.5)<1e-4);\n}"}
{"index": 160, "humaneval_task_id": "CPP/47", "focal_method_name": "median", "focal_method_para": "(vector<float> l)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-3)<1e-4);\n}"}
{"index": 161, "humaneval_task_id": "CPP/47", "focal_method_name": "median", "focal_method_para": "(vector<float> l)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-7)<1e-4);\n}"}
{"index": 162, "humaneval_task_id": "CPP/47", "focal_method_name": "median", "focal_method_para": "(vector<float> l)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-8.0)<1e-4);\n}"}
{"index": 163, "humaneval_task_id": "CPP/47", "focal_method_name": "median", "focal_method_para": "(vector<float> l)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-5)<1e-4);\n}"}
{"index": 164, "humaneval_task_id": "CPP/48", "focal_method_name": "is_palindrome", "focal_method_para": "(string text)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_palindrome(string text){\n    string pr(text.rbegin(),text.rend());\n    return pr==text;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_palindrome(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 165, "humaneval_task_id": "CPP/48", "focal_method_name": "is_palindrome", "focal_method_para": "(string text)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_palindrome(string text){\n    string pr(text.rbegin(),text.rend());\n    return pr==text;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_palindrome(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 166, "humaneval_task_id": "CPP/49", "focal_method_name": "modp", "focal_method_para": "(int n,int p)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 167, "humaneval_task_id": "CPP/49", "focal_method_name": "modp", "focal_method_para": "(int n,int p)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==4);\n}"}
{"index": 168, "humaneval_task_id": "CPP/49", "focal_method_name": "modp", "focal_method_para": "(int n,int p)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==8);\n}"}
{"index": 169, "humaneval_task_id": "CPP/49", "focal_method_name": "modp", "focal_method_para": "(int n,int p)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==3);\n}"}
{"index": 170, "humaneval_task_id": "CPP/49", "focal_method_name": "modp", "focal_method_para": "(int n,int p)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==2);\n}"}
{"index": 171, "humaneval_task_id": "CPP/51", "focal_method_name": "remove_vowels", "focal_method_para": "(string text)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"cB\");\n}"}
{"index": 172, "humaneval_task_id": "CPP/51", "focal_method_name": "remove_vowels", "focal_method_para": "(string text)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"fdcb\");\n}"}
{"index": 173, "humaneval_task_id": "CPP/51", "focal_method_name": "remove_vowels", "focal_method_para": "(string text)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"ybcd\");\n}"}
{"index": 174, "humaneval_task_id": "CPP/51", "focal_method_name": "remove_vowels", "focal_method_para": "(string text)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"\");\n}"}
{"index": 175, "humaneval_task_id": "CPP/51", "focal_method_name": "remove_vowels", "focal_method_para": "(string text)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"bcdf\\nghjklm\");\n}"}
{"index": 176, "humaneval_task_id": "CPP/52", "focal_method_name": "below_threshold", "focal_method_para": "(vector<int>l, int t)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool below_threshold(vector<int>l, int t){\n    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = below_threshold(<FILL_ME>);\n\tassert(result);\n}"}
{"index": 177, "humaneval_task_id": "CPP/52", "focal_method_name": "below_threshold", "focal_method_para": "(vector<int>l, int t)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool below_threshold(vector<int>l, int t){\n    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = below_threshold(<FILL_ME>);\n\tassert(not(result));\n}"}
{"index": 178, "humaneval_task_id": "CPP/53", "focal_method_name": "add", "focal_method_para": "(int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==12);\n}"}
{"index": 179, "humaneval_task_id": "CPP/53", "focal_method_name": "add", "focal_method_para": "(int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 180, "humaneval_task_id": "CPP/53", "focal_method_name": "add", "focal_method_para": "(int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==5);\n}"}
{"index": 181, "humaneval_task_id": "CPP/54", "focal_method_name": "same_chars", "focal_method_para": "(string s0,string s1)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool same_chars(string s0,string s1){\n    for (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = same_chars(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 182, "humaneval_task_id": "CPP/54", "focal_method_name": "same_chars", "focal_method_para": "(string s0,string s1)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool same_chars(string s0,string s1){\n    for (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = same_chars(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 183, "humaneval_task_id": "CPP/55", "focal_method_name": "fib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==21);\n}"}
{"index": 184, "humaneval_task_id": "CPP/55", "focal_method_name": "fib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==89);\n}"}
{"index": 185, "humaneval_task_id": "CPP/55", "focal_method_name": "fib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 186, "humaneval_task_id": "CPP/55", "focal_method_name": "fib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==55);\n}"}
{"index": 187, "humaneval_task_id": "CPP/55", "focal_method_name": "fib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==144);\n}"}
{"index": 188, "humaneval_task_id": "CPP/56", "focal_method_name": "correct_bracketing", "focal_method_para": "(string brackets)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(result);\n}"}
{"index": 189, "humaneval_task_id": "CPP/56", "focal_method_name": "correct_bracketing", "focal_method_para": "(string brackets)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(not(result));\n}"}
{"index": 190, "humaneval_task_id": "CPP/57", "focal_method_name": "monotonic", "focal_method_para": "(vector<float> l)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool monotonic(vector<float> l){\n    int incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = monotonic(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 191, "humaneval_task_id": "CPP/57", "focal_method_name": "monotonic", "focal_method_para": "(vector<float> l)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool monotonic(vector<float> l){\n    int incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = monotonic(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 192, "humaneval_task_id": "CPP/58", "focal_method_name": "common", "focal_method_para": "(vector<int> l1,vector<int> l2)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 193, "humaneval_task_id": "CPP/58", "focal_method_name": "common", "focal_method_para": "(vector<int> l1,vector<int> l2)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}"}
{"index": 194, "humaneval_task_id": "CPP/58", "focal_method_name": "common", "focal_method_para": "(vector<int> l1,vector<int> l2)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{1,5,653}));\n}"}
{"index": 195, "humaneval_task_id": "CPP/58", "focal_method_name": "common", "focal_method_para": "(vector<int> l1,vector<int> l2)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{2,3,4}));\n}"}
{"index": 196, "humaneval_task_id": "CPP/59", "focal_method_name": "largest_prime_factor", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==7);\n}"}
{"index": 197, "humaneval_task_id": "CPP/59", "focal_method_name": "largest_prime_factor", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==11);\n}"}
{"index": 198, "humaneval_task_id": "CPP/59", "focal_method_name": "largest_prime_factor", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==29);\n}"}
{"index": 199, "humaneval_task_id": "CPP/59", "focal_method_name": "largest_prime_factor", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==3);\n}"}
{"index": 200, "humaneval_task_id": "CPP/59", "focal_method_name": "largest_prime_factor", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==5);\n}"}
{"index": 201, "humaneval_task_id": "CPP/60", "focal_method_name": "sum_to_n", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==5050);\n}"}
{"index": 202, "humaneval_task_id": "CPP/60", "focal_method_name": "sum_to_n", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==21);\n}"}
{"index": 203, "humaneval_task_id": "CPP/60", "focal_method_name": "sum_to_n", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==66);\n}"}
{"index": 204, "humaneval_task_id": "CPP/60", "focal_method_name": "sum_to_n", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==465);\n}"}
{"index": 205, "humaneval_task_id": "CPP/60", "focal_method_name": "sum_to_n", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 206, "humaneval_task_id": "CPP/61", "focal_method_name": "correct_bracketing", "focal_method_para": "(string brackets)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(result);\n}"}
{"index": 207, "humaneval_task_id": "CPP/61", "focal_method_name": "correct_bracketing", "focal_method_para": "(string brackets)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(not(result));\n}"}
{"index": 208, "humaneval_task_id": "CPP/62", "focal_method_name": "derivative", "focal_method_para": "(vector<float> xs)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{1,4,12,20}));\n}"}
{"index": 209, "humaneval_task_id": "CPP/62", "focal_method_name": "derivative", "focal_method_para": "(vector<float> xs)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,6}));\n}"}
{"index": 210, "humaneval_task_id": "CPP/62", "focal_method_name": "derivative", "focal_method_para": "(vector<float> xs)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 211, "humaneval_task_id": "CPP/62", "focal_method_name": "derivative", "focal_method_para": "(vector<float> xs)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}"}
{"index": 212, "humaneval_task_id": "CPP/62", "focal_method_name": "derivative", "focal_method_para": "(vector<float> xs)", "focal_method_return_type": "vector<float>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,2,0,16}));\n}"}
{"index": 213, "humaneval_task_id": "CPP/63", "focal_method_name": "fibfib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==274);\n}"}
{"index": 214, "humaneval_task_id": "CPP/63", "focal_method_name": "fibfib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 215, "humaneval_task_id": "CPP/63", "focal_method_name": "fibfib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 216, "humaneval_task_id": "CPP/63", "focal_method_name": "fibfib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==81);\n}"}
{"index": 217, "humaneval_task_id": "CPP/63", "focal_method_name": "fibfib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==927);\n}"}
{"index": 218, "humaneval_task_id": "CPP/63", "focal_method_name": "fibfib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==4);\n}"}
{"index": 219, "humaneval_task_id": "CPP/63", "focal_method_name": "fibfib", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==24);\n}"}
{"index": 220, "humaneval_task_id": "CPP/64", "focal_method_name": "vowels_count", "focal_method_para": "(string s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==3);\n}"}
{"index": 221, "humaneval_task_id": "CPP/64", "focal_method_name": "vowels_count", "focal_method_para": "(string s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 222, "humaneval_task_id": "CPP/64", "focal_method_name": "vowels_count", "focal_method_para": "(string s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==2);\n}"}
{"index": 223, "humaneval_task_id": "CPP/65", "focal_method_name": "circular_shift", "focal_method_para": "(int x,int shift)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"21\");\n}"}
{"index": 224, "humaneval_task_id": "CPP/65", "focal_method_name": "circular_shift", "focal_method_para": "(int x,int shift)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"11\");\n}"}
{"index": 225, "humaneval_task_id": "CPP/65", "focal_method_name": "circular_shift", "focal_method_para": "(int x,int shift)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"001\");\n}"}
{"index": 226, "humaneval_task_id": "CPP/65", "focal_method_name": "circular_shift", "focal_method_para": "(int x,int shift)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"12\");\n}"}
{"index": 227, "humaneval_task_id": "CPP/65", "focal_method_name": "circular_shift", "focal_method_para": "(int x,int shift)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"79\");\n}"}
{"index": 228, "humaneval_task_id": "CPP/66", "focal_method_name": "digitSum", "focal_method_para": "(string s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==131);\n}"}
{"index": 229, "humaneval_task_id": "CPP/66", "focal_method_name": "digitSum", "focal_method_para": "(string s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 230, "humaneval_task_id": "CPP/66", "focal_method_name": "digitSum", "focal_method_para": "(string s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==151);\n}"}
{"index": 231, "humaneval_task_id": "CPP/66", "focal_method_name": "digitSum", "focal_method_para": "(string s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==153);\n}"}
{"index": 232, "humaneval_task_id": "CPP/66", "focal_method_name": "digitSum", "focal_method_para": "(string s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==69);\n}"}
{"index": 233, "humaneval_task_id": "CPP/66", "focal_method_name": "digitSum", "focal_method_para": "(string s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==67);\n}"}
{"index": 234, "humaneval_task_id": "CPP/66", "focal_method_name": "digitSum", "focal_method_para": "(string s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==327);\n}"}
{"index": 235, "humaneval_task_id": "CPP/67", "focal_method_name": "fruit_distribution", "focal_method_para": "(string s,int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 236, "humaneval_task_id": "CPP/67", "focal_method_name": "fruit_distribution", "focal_method_para": "(string s,int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==95);\n}"}
{"index": 237, "humaneval_task_id": "CPP/67", "focal_method_name": "fruit_distribution", "focal_method_para": "(string s,int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==19);\n}"}
{"index": 238, "humaneval_task_id": "CPP/67", "focal_method_name": "fruit_distribution", "focal_method_para": "(string s,int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==10);\n}"}
{"index": 239, "humaneval_task_id": "CPP/67", "focal_method_name": "fruit_distribution", "focal_method_para": "(string s,int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==8);\n}"}
{"index": 240, "humaneval_task_id": "CPP/67", "focal_method_name": "fruit_distribution", "focal_method_para": "(string s,int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==2);\n}"}
{"index": 241, "humaneval_task_id": "CPP/68", "focal_method_name": "pluck", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{6,1}));\n}"}
{"index": 242, "humaneval_task_id": "CPP/68", "focal_method_name": "pluck", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}"}
{"index": 243, "humaneval_task_id": "CPP/68", "focal_method_name": "pluck", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{4,1}));\n}"}
{"index": 244, "humaneval_task_id": "CPP/68", "focal_method_name": "pluck", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 245, "humaneval_task_id": "CPP/68", "focal_method_name": "pluck", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{0,3}));\n}"}
{"index": 246, "humaneval_task_id": "CPP/68", "focal_method_name": "pluck", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{2,1}));\n}"}
{"index": 247, "humaneval_task_id": "CPP/69", "focal_method_name": "search", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 248, "humaneval_task_id": "CPP/69", "focal_method_name": "search", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==5);\n}"}
{"index": 249, "humaneval_task_id": "CPP/69", "focal_method_name": "search", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==4);\n}"}
{"index": 250, "humaneval_task_id": "CPP/69", "focal_method_name": "search", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==8);\n}"}
{"index": 251, "humaneval_task_id": "CPP/69", "focal_method_name": "search", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==-1);\n}"}
{"index": 252, "humaneval_task_id": "CPP/69", "focal_method_name": "search", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==2);\n}"}
{"index": 253, "humaneval_task_id": "CPP/70", "focal_method_name": "strange_sort_list", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,5,2,4,3}));\n}"}
{"index": 254, "humaneval_task_id": "CPP/70", "focal_method_name": "strange_sort_list", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,8,2,7,3,6,4,5}));\n}"}
{"index": 255, "humaneval_task_id": "CPP/70", "focal_method_name": "strange_sort_list", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{-5,5,-5,5,0,2,2,2}));\n}"}
{"index": 256, "humaneval_task_id": "CPP/70", "focal_method_name": "strange_sort_list", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,9,5,8,6,7}));\n}"}
{"index": 257, "humaneval_task_id": "CPP/70", "focal_method_name": "strange_sort_list", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,4,2,3}));\n}"}
{"index": 258, "humaneval_task_id": "CPP/70", "focal_method_name": "strange_sort_list", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{5,9,6,8,7}));\n}"}
{"index": 259, "humaneval_task_id": "CPP/70", "focal_method_name": "strange_sort_list", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 260, "humaneval_task_id": "CPP/70", "focal_method_name": "strange_sort_list", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{5,5,5,5}));\n}"}
{"index": 261, "humaneval_task_id": "CPP/70", "focal_method_name": "strange_sort_list", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{111111}));\n}"}
{"index": 262, "humaneval_task_id": "CPP/71", "focal_method_name": "triangle_area", "focal_method_para": "(float a,float b,float c)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-16.25)<0.01);\n}"}
{"index": 263, "humaneval_task_id": "CPP/71", "focal_method_name": "triangle_area", "focal_method_para": "(float a,float b,float c)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-0.43)<0.01);\n}"}
{"index": 264, "humaneval_task_id": "CPP/71", "focal_method_name": "triangle_area", "focal_method_para": "(float a,float b,float c)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-6.00)<0.01);\n}"}
{"index": 265, "humaneval_task_id": "CPP/71", "focal_method_name": "triangle_area", "focal_method_para": "(float a,float b,float c)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-1.73)<0.01);\n}"}
{"index": 266, "humaneval_task_id": "CPP/71", "focal_method_name": "triangle_area", "focal_method_para": "(float a,float b,float c)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result+1)<0.01);\n}"}
{"index": 267, "humaneval_task_id": "CPP/71", "focal_method_name": "triangle_area", "focal_method_para": "(float a,float b,float c)", "focal_method_return_type": "float", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-8.18)<0.01);\n}"}
{"index": 268, "humaneval_task_id": "CPP/72", "focal_method_name": "will_it_fly", "focal_method_para": "(vector<int> q,int w)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool will_it_fly(vector<int> q,int w){\n    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = will_it_fly(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 269, "humaneval_task_id": "CPP/72", "focal_method_name": "will_it_fly", "focal_method_para": "(vector<int> q,int w)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool will_it_fly(vector<int> q,int w){\n    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = will_it_fly(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 270, "humaneval_task_id": "CPP/73", "focal_method_name": "smallest_change", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 271, "humaneval_task_id": "CPP/73", "focal_method_name": "smallest_change", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==4);\n}"}
{"index": 272, "humaneval_task_id": "CPP/73", "focal_method_name": "smallest_change", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 273, "humaneval_task_id": "CPP/74", "focal_method_name": "total_match", "focal_method_para": "(vector<string> lst1,vector<string> lst2)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hi\",\"admin\"}));\n}"}
{"index": 274, "humaneval_task_id": "CPP/74", "focal_method_name": "total_match", "focal_method_para": "(vector<string> lst1,vector<string> lst2)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hi\",\"hi\"}));\n}"}
{"index": 275, "humaneval_task_id": "CPP/74", "focal_method_name": "total_match", "focal_method_para": "(vector<string> lst1,vector<string> lst2)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hI\",\"Hi\"}));\n}"}
{"index": 276, "humaneval_task_id": "CPP/74", "focal_method_name": "total_match", "focal_method_para": "(vector<string> lst1,vector<string> lst2)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hI\",\"hi\",\"hi\"}));\n}"}
{"index": 277, "humaneval_task_id": "CPP/74", "focal_method_name": "total_match", "focal_method_para": "(vector<string> lst1,vector<string> lst2)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 278, "humaneval_task_id": "CPP/74", "focal_method_name": "total_match", "focal_method_para": "(vector<string> lst1,vector<string> lst2)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"4\"}));\n}"}
{"index": 279, "humaneval_task_id": "CPP/75", "focal_method_name": "is_multiply_prime", "focal_method_para": "(int a)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_multiply_prime(int a){\n    int num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_multiply_prime(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 280, "humaneval_task_id": "CPP/75", "focal_method_name": "is_multiply_prime", "focal_method_para": "(int a)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_multiply_prime(int a){\n    int num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_multiply_prime(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 281, "humaneval_task_id": "CPP/76", "focal_method_name": "is_simple_power", "focal_method_para": "(int x,int n)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_simple_power(int x,int n){\n    int p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_simple_power(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 282, "humaneval_task_id": "CPP/76", "focal_method_name": "is_simple_power", "focal_method_para": "(int x,int n)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_simple_power(int x,int n){\n    int p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_simple_power(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 283, "humaneval_task_id": "CPP/77", "focal_method_name": "iscuber", "focal_method_para": "(int a)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool iscuber(int a){\n    for (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = iscuber(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 284, "humaneval_task_id": "CPP/77", "focal_method_name": "iscuber", "focal_method_para": "(int a)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool iscuber(int a){\n    for (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = iscuber(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 285, "humaneval_task_id": "CPP/78", "focal_method_name": "hex_key", "focal_method_para": "(string num)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==12);\n}"}
{"index": 286, "humaneval_task_id": "CPP/78", "focal_method_name": "hex_key", "focal_method_para": "(string num)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 287, "humaneval_task_id": "CPP/78", "focal_method_name": "hex_key", "focal_method_para": "(string num)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 288, "humaneval_task_id": "CPP/78", "focal_method_name": "hex_key", "focal_method_para": "(string num)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==6);\n}"}
{"index": 289, "humaneval_task_id": "CPP/78", "focal_method_name": "hex_key", "focal_method_para": "(string num)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==4);\n}"}
{"index": 290, "humaneval_task_id": "CPP/78", "focal_method_name": "hex_key", "focal_method_para": "(string num)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==2);\n}"}
{"index": 291, "humaneval_task_id": "CPP/79", "focal_method_name": "decimal_to_binary", "focal_method_para": "(int decimal)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db100000db\");\n}"}
{"index": 292, "humaneval_task_id": "CPP/79", "focal_method_name": "decimal_to_binary", "focal_method_para": "(int decimal)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db1100111db\");\n}"}
{"index": 293, "humaneval_task_id": "CPP/79", "focal_method_name": "decimal_to_binary", "focal_method_para": "(int decimal)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db1111db\");\n}"}
{"index": 294, "humaneval_task_id": "CPP/79", "focal_method_name": "decimal_to_binary", "focal_method_para": "(int decimal)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db0db\");\n}"}
{"index": 295, "humaneval_task_id": "CPP/80", "focal_method_name": "is_happy", "focal_method_para": "(string s)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_happy(string s){\n    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_happy(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 296, "humaneval_task_id": "CPP/80", "focal_method_name": "is_happy", "focal_method_para": "(string s)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_happy(string s){\n    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_happy(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 297, "humaneval_task_id": "CPP/81", "focal_method_name": "numerical_letter_grade", "focal_method_para": "(vector<float> grades)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D+\"}));\n}"}
{"index": 298, "humaneval_task_id": "CPP/81", "focal_method_name": "numerical_letter_grade", "focal_method_para": "(vector<float> grades)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D-\"}));\n}"}
{"index": 299, "humaneval_task_id": "CPP/81", "focal_method_name": "numerical_letter_grade", "focal_method_para": "(vector<float> grades)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"E\",\"D-\"}));\n}"}
{"index": 300, "humaneval_task_id": "CPP/81", "focal_method_name": "numerical_letter_grade", "focal_method_para": "(vector<float> grades)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"A+\",\"B\",\"C-\",\"C\",\"A-\"}));\n}"}
{"index": 301, "humaneval_task_id": "CPP/81", "focal_method_name": "numerical_letter_grade", "focal_method_para": "(vector<float> grades)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D\",\"D-\",\"C-\",\"B\",\"B+\"}));\n}"}
{"index": 302, "humaneval_task_id": "CPP/81", "focal_method_name": "numerical_letter_grade", "focal_method_para": "(vector<float> grades)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"E\"}));\n}"}
{"index": 303, "humaneval_task_id": "CPP/82", "focal_method_name": "prime_length", "focal_method_para": "(string str)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool prime_length(string str){\n    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prime_length(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 304, "humaneval_task_id": "CPP/82", "focal_method_name": "prime_length", "focal_method_para": "(string str)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool prime_length(string str){\n    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prime_length(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 305, "humaneval_task_id": "CPP/83", "focal_method_name": "starts_one_ends", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 306, "humaneval_task_id": "CPP/83", "focal_method_name": "starts_one_ends", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==1800);\n}"}
{"index": 307, "humaneval_task_id": "CPP/83", "focal_method_name": "starts_one_ends", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==18);\n}"}
{"index": 308, "humaneval_task_id": "CPP/83", "focal_method_name": "starts_one_ends", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==18000);\n}"}
{"index": 309, "humaneval_task_id": "CPP/83", "focal_method_name": "starts_one_ends", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==180);\n}"}
{"index": 310, "humaneval_task_id": "CPP/84", "focal_method_name": "solve", "focal_method_para": "(int N)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"110\");\n}"}
{"index": 311, "humaneval_task_id": "CPP/84", "focal_method_name": "solve", "focal_method_para": "(int N)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1\");\n}"}
{"index": 312, "humaneval_task_id": "CPP/84", "focal_method_name": "solve", "focal_method_para": "(int N)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"10010\");\n}"}
{"index": 313, "humaneval_task_id": "CPP/84", "focal_method_name": "solve", "focal_method_para": "(int N)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1100\");\n}"}
{"index": 314, "humaneval_task_id": "CPP/84", "focal_method_name": "solve", "focal_method_para": "(int N)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1001\");\n}"}
{"index": 315, "humaneval_task_id": "CPP/85", "focal_method_name": "add", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==122);\n}"}
{"index": 316, "humaneval_task_id": "CPP/85", "focal_method_name": "add", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==12);\n}"}
{"index": 317, "humaneval_task_id": "CPP/85", "focal_method_name": "add", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 318, "humaneval_task_id": "CPP/85", "focal_method_name": "add", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==88);\n}"}
{"index": 319, "humaneval_task_id": "CPP/86", "focal_method_name": "anti_shuffle", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\".HiMyaemnisMeirst.RbootHowaer?ouy\");\n}"}
{"index": 320, "humaneval_task_id": "CPP/86", "focal_method_name": "anti_shuffle", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"Hi\");\n}"}
{"index": 321, "humaneval_task_id": "CPP/86", "focal_method_name": "anti_shuffle", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"abcd\");\n}"}
{"index": 322, "humaneval_task_id": "CPP/86", "focal_method_name": "anti_shuffle", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"ehllo\");\n}"}
{"index": 323, "humaneval_task_id": "CPP/86", "focal_method_name": "anti_shuffle", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"Hello!!!Wdlor\");\n}"}
{"index": 324, "humaneval_task_id": "CPP/86", "focal_method_name": "anti_shuffle", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"\");\n}"}
{"index": 325, "humaneval_task_id": "CPP/86", "focal_method_name": "anti_shuffle", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"bemnru\");\n}"}
{"index": 326, "humaneval_task_id": "CPP/87", "focal_method_name": "get_row", "focal_method_para": "(vector<vector<int>> lst, int x)", "focal_method_return_type": "vector<vector<int>>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassertresult;\n}"}
{"index": 327, "humaneval_task_id": "CPP/87", "focal_method_name": "get_row", "focal_method_para": "(vector<vector<int>> lst, int x)", "focal_method_return_type": "vector<vector<int>>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 328, "humaneval_task_id": "CPP/87", "focal_method_name": "get_row", "focal_method_para": "(vector<vector<int>> lst, int x)", "focal_method_return_type": "vector<vector<int>>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassert(issame(result,{{2,2}}));\n}"}
{"index": 329, "humaneval_task_id": "CPP/88", "focal_method_name": "sort_array", "focal_method_para": "(vector<int> array)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{23,21,14,11}));\n}"}
{"index": 330, "humaneval_task_id": "CPP/88", "focal_method_name": "sort_array", "focal_method_para": "(vector<int> array)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{6,5,4,3,2,1,0}));\n}"}
{"index": 331, "humaneval_task_id": "CPP/88", "focal_method_name": "sort_array", "focal_method_para": "(vector<int> array)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{1,2}));\n}"}
{"index": 332, "humaneval_task_id": "CPP/88", "focal_method_name": "sort_array", "focal_method_para": "(vector<int> array)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,11,15,32,42,87}));\n}"}
{"index": 333, "humaneval_task_id": "CPP/88", "focal_method_name": "sort_array", "focal_method_para": "(vector<int> array)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 334, "humaneval_task_id": "CPP/88", "focal_method_name": "sort_array", "focal_method_para": "(vector<int> array)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{5}));\n}"}
{"index": 335, "humaneval_task_id": "CPP/88", "focal_method_name": "sort_array", "focal_method_para": "(vector<int> array)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,1,2,3,4,5}));\n}"}
{"index": 336, "humaneval_task_id": "CPP/89", "focal_method_name": "encrypt", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n}"}
{"index": 337, "humaneval_task_id": "CPP/89", "focal_method_name": "encrypt", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"lippsqcjvmirh\");\n}"}
{"index": 338, "humaneval_task_id": "CPP/89", "focal_method_name": "encrypt", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"ix\");\n}"}
{"index": 339, "humaneval_task_id": "CPP/89", "focal_method_name": "encrypt", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"ewhjklnop\");\n}"}
{"index": 340, "humaneval_task_id": "CPP/89", "focal_method_name": "encrypt", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"e\");\n}"}
{"index": 341, "humaneval_task_id": "CPP/89", "focal_method_name": "encrypt", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"jeiajeaijeiak\");\n}"}
{"index": 342, "humaneval_task_id": "CPP/89", "focal_method_name": "encrypt", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"lm\");\n}"}
{"index": 343, "humaneval_task_id": "CPP/89", "focal_method_name": "encrypt", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"kj\");\n}"}
{"index": 344, "humaneval_task_id": "CPP/90", "focal_method_name": "next_smallest", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 345, "humaneval_task_id": "CPP/90", "focal_method_name": "next_smallest", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==-1);\n}"}
{"index": 346, "humaneval_task_id": "CPP/90", "focal_method_name": "next_smallest", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==-35);\n}"}
{"index": 347, "humaneval_task_id": "CPP/90", "focal_method_name": "next_smallest", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==2);\n}"}
{"index": 348, "humaneval_task_id": "CPP/91", "focal_method_name": "is_bored", "focal_method_para": "(string S)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 349, "humaneval_task_id": "CPP/91", "focal_method_name": "is_bored", "focal_method_para": "(string S)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 350, "humaneval_task_id": "CPP/91", "focal_method_name": "is_bored", "focal_method_para": "(string S)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==2);\n}"}
{"index": 351, "humaneval_task_id": "CPP/92", "focal_method_name": "any_int", "focal_method_para": "(float a,float b,float c)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool any_int(float a,float b,float c){\n    if (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = any_int(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 352, "humaneval_task_id": "CPP/92", "focal_method_name": "any_int", "focal_method_para": "(float a,float b,float c)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool any_int(float a,float b,float c){\n    if (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = any_int(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 353, "humaneval_task_id": "CPP/93", "focal_method_name": "encode", "focal_method_para": "(string message)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"tHKSKSCMGSSCGG\");\n}"}
{"index": 354, "humaneval_task_id": "CPP/93", "focal_method_name": "encode", "focal_method_para": "(string message)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"kdQnTkNqWwHcTTqwRkTg\");\n}"}
{"index": 355, "humaneval_task_id": "CPP/93", "focal_method_name": "encode", "focal_method_para": "(string message)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"tgst\");\n}"}
{"index": 356, "humaneval_task_id": "CPP/93", "focal_method_name": "encode", "focal_method_para": "(string message)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"mWDCSKR\");\n}"}
{"index": 357, "humaneval_task_id": "CPP/93", "focal_method_name": "encode", "focal_method_para": "(string message)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"ygs\");\n}"}
{"index": 358, "humaneval_task_id": "CPP/94", "focal_method_name": "skjkasdkd", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==7);\n}"}
{"index": 359, "humaneval_task_id": "CPP/94", "focal_method_name": "skjkasdkd", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==11);\n}"}
{"index": 360, "humaneval_task_id": "CPP/94", "focal_method_name": "skjkasdkd", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==25);\n}"}
{"index": 361, "humaneval_task_id": "CPP/94", "focal_method_name": "skjkasdkd", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==19);\n}"}
{"index": 362, "humaneval_task_id": "CPP/94", "focal_method_name": "skjkasdkd", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==10);\n}"}
{"index": 363, "humaneval_task_id": "CPP/94", "focal_method_name": "skjkasdkd", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==3);\n}"}
{"index": 364, "humaneval_task_id": "CPP/94", "focal_method_name": "skjkasdkd", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==13);\n}"}
{"index": 365, "humaneval_task_id": "CPP/95", "focal_method_name": "check_dict_case", "focal_method_para": "(map<string,string> dict)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = check_dict_case(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 366, "humaneval_task_id": "CPP/95", "focal_method_name": "check_dict_case", "focal_method_para": "(map<string,string> dict)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = check_dict_case(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 367, "humaneval_task_id": "CPP/96", "focal_method_name": "count_up_to", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5}));\n}"}
{"index": 368, "humaneval_task_id": "CPP/96", "focal_method_name": "count_up_to", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7}));\n}"}
{"index": 369, "humaneval_task_id": "CPP/96", "focal_method_name": "count_up_to", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17}));\n}"}
{"index": 370, "humaneval_task_id": "CPP/96", "focal_method_name": "count_up_to", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97}));\n}"}
{"index": 371, "humaneval_task_id": "CPP/96", "focal_method_name": "count_up_to", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19}));\n}"}
{"index": 372, "humaneval_task_id": "CPP/96", "focal_method_name": "count_up_to", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19,23,29,31,37,41,43}));\n}"}
{"index": 373, "humaneval_task_id": "CPP/96", "focal_method_name": "count_up_to", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}"}
{"index": 374, "humaneval_task_id": "CPP/96", "focal_method_name": "count_up_to", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 375, "humaneval_task_id": "CPP/97", "focal_method_name": "multiply", "focal_method_para": "(int a,int b)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==42);\n}"}
{"index": 376, "humaneval_task_id": "CPP/97", "focal_method_name": "multiply", "focal_method_para": "(int a,int b)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 377, "humaneval_task_id": "CPP/97", "focal_method_name": "multiply", "focal_method_para": "(int a,int b)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==16);\n}"}
{"index": 378, "humaneval_task_id": "CPP/97", "focal_method_name": "multiply", "focal_method_para": "(int a,int b)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==72);\n}"}
{"index": 379, "humaneval_task_id": "CPP/97", "focal_method_name": "multiply", "focal_method_para": "(int a,int b)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==20);\n}"}
{"index": 380, "humaneval_task_id": "CPP/97", "focal_method_name": "multiply", "focal_method_para": "(int a,int b)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==49);\n}"}
{"index": 381, "humaneval_task_id": "CPP/98", "focal_method_name": "count_upper", "focal_method_para": "(string s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 382, "humaneval_task_id": "CPP/98", "focal_method_name": "count_upper", "focal_method_para": "(string s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 383, "humaneval_task_id": "CPP/98", "focal_method_name": "count_upper", "focal_method_para": "(string s)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==2);\n}"}
{"index": 384, "humaneval_task_id": "CPP/99", "focal_method_name": "closest_integer", "focal_method_para": "(string value)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==-16);\n}"}
{"index": 385, "humaneval_task_id": "CPP/99", "focal_method_name": "closest_integer", "focal_method_para": "(string value)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 386, "humaneval_task_id": "CPP/99", "focal_method_name": "closest_integer", "focal_method_para": "(string value)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==15);\n}"}
{"index": 387, "humaneval_task_id": "CPP/99", "focal_method_name": "closest_integer", "focal_method_para": "(string value)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==10);\n}"}
{"index": 388, "humaneval_task_id": "CPP/100", "focal_method_name": "make_a_pile", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{3,5,7}));\n}"}
{"index": 389, "humaneval_task_id": "CPP/100", "focal_method_name": "make_a_pile", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{6,8,10,12,14,16}));\n}"}
{"index": 390, "humaneval_task_id": "CPP/100", "focal_method_name": "make_a_pile", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{8,10,12,14,16,18,20,22}));\n}"}
{"index": 391, "humaneval_task_id": "CPP/100", "focal_method_name": "make_a_pile", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{5,7,9,11,13}));\n}"}
{"index": 392, "humaneval_task_id": "CPP/100", "focal_method_name": "make_a_pile", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{4,6,8,10}));\n}"}
{"index": 393, "humaneval_task_id": "CPP/101", "focal_method_name": "words_string", "focal_method_para": "(string s)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"}));\n}"}
{"index": 394, "humaneval_task_id": "CPP/101", "focal_method_name": "words_string", "focal_method_para": "(string s)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"Hi\",\"my\",\"name\"}));\n}"}
{"index": 395, "humaneval_task_id": "CPP/101", "focal_method_name": "words_string", "focal_method_para": "(string s)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 396, "humaneval_task_id": "CPP/101", "focal_method_name": "words_string", "focal_method_para": "(string s)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"ahmed\",\"gamal\"}));\n}"}
{"index": 397, "humaneval_task_id": "CPP/101", "focal_method_name": "words_string", "focal_method_para": "(string s)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"Hi\",\"my\",\"name\",\"is\",\"John\"}));\n}"}
{"index": 398, "humaneval_task_id": "CPP/102", "focal_method_name": "choose_num", "focal_method_para": "(int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==14);\n}"}
{"index": 399, "humaneval_task_id": "CPP/102", "focal_method_name": "choose_num", "focal_method_para": "(int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==12354);\n}"}
{"index": 400, "humaneval_task_id": "CPP/102", "focal_method_name": "choose_num", "focal_method_para": "(int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==28);\n}"}
{"index": 401, "humaneval_task_id": "CPP/102", "focal_method_name": "choose_num", "focal_method_para": "(int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==546);\n}"}
{"index": 402, "humaneval_task_id": "CPP/102", "focal_method_name": "choose_num", "focal_method_para": "(int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==-1);\n}"}
{"index": 403, "humaneval_task_id": "CPP/103", "focal_method_name": "rounded_avg", "focal_method_para": "(int n,int m)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"101\");\n}"}
{"index": 404, "humaneval_task_id": "CPP/103", "focal_method_name": "rounded_avg", "focal_method_para": "(int n,int m)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"101101101\");\n}"}
{"index": 405, "humaneval_task_id": "CPP/103", "focal_method_name": "rounded_avg", "focal_method_para": "(int n,int m)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1111100100\");\n}"}
{"index": 406, "humaneval_task_id": "CPP/103", "focal_method_name": "rounded_avg", "focal_method_para": "(int n,int m)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1011000001\");\n}"}
{"index": 407, "humaneval_task_id": "CPP/103", "focal_method_name": "rounded_avg", "focal_method_para": "(int n,int m)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"11010111\");\n}"}
{"index": 408, "humaneval_task_id": "CPP/103", "focal_method_name": "rounded_avg", "focal_method_para": "(int n,int m)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"11\");\n}"}
{"index": 409, "humaneval_task_id": "CPP/103", "focal_method_name": "rounded_avg", "focal_method_para": "(int n,int m)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1010\");\n}"}
{"index": 410, "humaneval_task_id": "CPP/103", "focal_method_name": "rounded_avg", "focal_method_para": "(int n,int m)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"110101101\");\n}"}
{"index": 411, "humaneval_task_id": "CPP/103", "focal_method_name": "rounded_avg", "focal_method_para": "(int n,int m)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1111001010\");\n}"}
{"index": 412, "humaneval_task_id": "CPP/103", "focal_method_name": "rounded_avg", "focal_method_para": "(int n,int m)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1001110010\");\n}"}
{"index": 413, "humaneval_task_id": "CPP/103", "focal_method_name": "rounded_avg", "focal_method_para": "(int n,int m)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"-1\");\n}"}
{"index": 414, "humaneval_task_id": "CPP/104", "focal_method_name": "unique_digits", "focal_method_para": "(vector<int> x)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{31,135}));\n}"}
{"index": 415, "humaneval_task_id": "CPP/104", "focal_method_name": "unique_digits", "focal_method_para": "(vector<int> x)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{1,15,33}));\n}"}
{"index": 416, "humaneval_task_id": "CPP/104", "focal_method_name": "unique_digits", "focal_method_para": "(vector<int> x)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{111,151}));\n}"}
{"index": 417, "humaneval_task_id": "CPP/104", "focal_method_name": "unique_digits", "focal_method_para": "(vector<int> x)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 418, "humaneval_task_id": "CPP/105", "focal_method_name": "by_length", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"}));\n}"}
{"index": 419, "humaneval_task_id": "CPP/105", "focal_method_name": "by_length", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Nine\",\"Eight\",\"Four\"}));\n}"}
{"index": 420, "humaneval_task_id": "CPP/105", "focal_method_name": "by_length", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Three\",\"Two\",\"One\"}));\n}"}
{"index": 421, "humaneval_task_id": "CPP/105", "focal_method_name": "by_length", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"One\"}));\n}"}
{"index": 422, "humaneval_task_id": "CPP/105", "focal_method_name": "by_length", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 423, "humaneval_task_id": "CPP/106", "focal_method_name": "f", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6,24,15,720,28}));\n}"}
{"index": 424, "humaneval_task_id": "CPP/106", "focal_method_name": "f", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1}));\n}"}
{"index": 425, "humaneval_task_id": "CPP/106", "focal_method_name": "f", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6,24,15}));\n}"}
{"index": 426, "humaneval_task_id": "CPP/106", "focal_method_name": "f", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6}));\n}"}
{"index": 427, "humaneval_task_id": "CPP/107", "focal_method_name": "even_odd_palindrome", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{4,6}));\n}"}
{"index": 428, "humaneval_task_id": "CPP/107", "focal_method_name": "even_odd_palindrome", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{5,6}));\n}"}
{"index": 429, "humaneval_task_id": "CPP/107", "focal_method_name": "even_odd_palindrome", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{8,13}));\n}"}
{"index": 430, "humaneval_task_id": "CPP/107", "focal_method_name": "even_odd_palindrome", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{1,2}));\n}"}
{"index": 431, "humaneval_task_id": "CPP/107", "focal_method_name": "even_odd_palindrome", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}"}
{"index": 432, "humaneval_task_id": "CPP/107", "focal_method_name": "even_odd_palindrome", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{6,8}));\n}"}
{"index": 433, "humaneval_task_id": "CPP/107", "focal_method_name": "even_odd_palindrome", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{4,5}));\n}"}
{"index": 434, "humaneval_task_id": "CPP/108", "focal_method_name": "count_nums", "focal_method_para": "(vector<int> n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 435, "humaneval_task_id": "CPP/108", "focal_method_name": "count_nums", "focal_method_para": "(vector<int> n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 436, "humaneval_task_id": "CPP/108", "focal_method_name": "count_nums", "focal_method_para": "(vector<int> n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==6);\n}"}
{"index": 437, "humaneval_task_id": "CPP/108", "focal_method_name": "count_nums", "focal_method_para": "(vector<int> n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==4);\n}"}
{"index": 438, "humaneval_task_id": "CPP/108", "focal_method_name": "count_nums", "focal_method_para": "(vector<int> n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==5);\n}"}
{"index": 439, "humaneval_task_id": "CPP/109", "focal_method_name": "move_one_ball", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool move_one_ball(vector<int> arr){\n    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = move_one_ball(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 440, "humaneval_task_id": "CPP/109", "focal_method_name": "move_one_ball", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool move_one_ball(vector<int> arr){\n    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = move_one_ball(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 441, "humaneval_task_id": "CPP/110", "focal_method_name": "exchange", "focal_method_para": "(vector<int> lst1,vector<int> lst2)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring exchange(vector<int> lst1,vector<int> lst2){\n    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = exchange(<FILL_ME>);\n\tassert(result==\"NO\");\n}"}
{"index": 442, "humaneval_task_id": "CPP/110", "focal_method_name": "exchange", "focal_method_para": "(vector<int> lst1,vector<int> lst2)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring exchange(vector<int> lst1,vector<int> lst2){\n    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = exchange(<FILL_ME>);\n\tassert(result==\"YES\");\n}"}
{"index": 443, "humaneval_task_id": "CPP/111", "focal_method_name": "histogram", "focal_method_para": "(string test)", "focal_method_return_type": "map<char,int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'b',4}}));\n}"}
{"index": 444, "humaneval_task_id": "CPP/111", "focal_method_name": "histogram", "focal_method_para": "(string test)", "focal_method_return_type": "map<char,int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',1}}));\n}"}
{"index": 445, "humaneval_task_id": "CPP/111", "focal_method_name": "histogram", "focal_method_para": "(string test)", "focal_method_return_type": "map<char,int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n}"}
{"index": 446, "humaneval_task_id": "CPP/111", "focal_method_name": "histogram", "focal_method_para": "(string test)", "focal_method_return_type": "map<char,int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'r',1},{'t',1},{'g',1}}));\n}"}
{"index": 447, "humaneval_task_id": "CPP/111", "focal_method_name": "histogram", "focal_method_para": "(string test)", "focal_method_return_type": "map<char,int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 448, "humaneval_task_id": "CPP/111", "focal_method_name": "histogram", "focal_method_para": "(string test)", "focal_method_return_type": "map<char,int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',2},{'b',2}}));\n}"}
{"index": 449, "humaneval_task_id": "CPP/112", "focal_method_name": "reverse_delete", "focal_method_para": "(string s,string c)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"cdedc\",\"True\"}));\n}"}
{"index": 450, "humaneval_task_id": "CPP/112", "focal_method_name": "reverse_delete", "focal_method_para": "(string s,string c)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"abba\",\"True\"}));\n}"}
{"index": 451, "humaneval_task_id": "CPP/112", "focal_method_name": "reverse_delete", "focal_method_para": "(string s,string c)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"\",\"True\"}));\n}"}
{"index": 452, "humaneval_task_id": "CPP/112", "focal_method_name": "reverse_delete", "focal_method_para": "(string s,string c)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"acdef\",\"False\"}));\n}"}
{"index": 453, "humaneval_task_id": "CPP/112", "focal_method_name": "reverse_delete", "focal_method_para": "(string s,string c)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"abcdedcba\",\"True\"}));\n}"}
{"index": 454, "humaneval_task_id": "CPP/112", "focal_method_name": "reverse_delete", "focal_method_para": "(string s,string c)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"dik\",\"False\"}));\n}"}
{"index": 455, "humaneval_task_id": "CPP/112", "focal_method_name": "reverse_delete", "focal_method_para": "(string s,string c)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"bcd\",\"False\"}));\n}"}
{"index": 456, "humaneval_task_id": "CPP/113", "focal_method_name": "odd_count", "focal_method_para": "(vector<string> lst)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassertassert(issame(result,{\n\"thenumberofoddelements2nthestr2ng2ofthe2nput.\",\n\"thenumberofoddelements3nthestr3ng3ofthe3nput.\",\n\"thenumberofoddelements2nthestr2ng2ofthe2nput.\"\n}));;\n}"}
{"index": 457, "humaneval_task_id": "CPP/113", "focal_method_name": "odd_count", "focal_method_para": "(vector<string> lst)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassert(issame(result,{\"thenumberofoddelements1nthestr1ng1ofthe1nput.\",\"thenumberofoddelements8nthestr8ng8ofthe8nput.\"}));\n}"}
{"index": 458, "humaneval_task_id": "CPP/113", "focal_method_name": "odd_count", "focal_method_para": "(vector<string> lst)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassert(issame(result,{\"thenumberofoddelements4nthestr4ng4ofthe4nput.\"}));\n}"}
{"index": 459, "humaneval_task_id": "CPP/114", "focal_method_name": "minSubArraySum", "focal_method_para": "(vector<long long> nums)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 460, "humaneval_task_id": "CPP/114", "focal_method_name": "minSubArraySum", "focal_method_para": "(vector<long long> nums)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-6);\n}"}
{"index": 461, "humaneval_task_id": "CPP/114", "focal_method_name": "minSubArraySum", "focal_method_para": "(vector<long long> nums)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-9999999999999999);\n}"}
{"index": 462, "humaneval_task_id": "CPP/114", "focal_method_name": "minSubArraySum", "focal_method_para": "(vector<long long> nums)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==7);\n}"}
{"index": 463, "humaneval_task_id": "CPP/114", "focal_method_name": "minSubArraySum", "focal_method_para": "(vector<long long> nums)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-10);\n}"}
{"index": 464, "humaneval_task_id": "CPP/114", "focal_method_name": "minSubArraySum", "focal_method_para": "(vector<long long> nums)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 465, "humaneval_task_id": "CPP/114", "focal_method_name": "minSubArraySum", "focal_method_para": "(vector<long long> nums)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==3);\n}"}
{"index": 466, "humaneval_task_id": "CPP/114", "focal_method_name": "minSubArraySum", "focal_method_para": "(vector<long long> nums)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-1);\n}"}
{"index": 467, "humaneval_task_id": "CPP/114", "focal_method_name": "minSubArraySum", "focal_method_para": "(vector<long long> nums)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-33);\n}"}
{"index": 468, "humaneval_task_id": "CPP/114", "focal_method_name": "minSubArraySum", "focal_method_para": "(vector<long long> nums)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-14);\n}"}
{"index": 469, "humaneval_task_id": "CPP/115", "focal_method_name": "max_fill", "focal_method_para": "(vector<vector<int>> grid,int capacity)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 470, "humaneval_task_id": "CPP/115", "focal_method_name": "max_fill", "focal_method_para": "(vector<vector<int>> grid,int capacity)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==6);\n}"}
{"index": 471, "humaneval_task_id": "CPP/115", "focal_method_name": "max_fill", "focal_method_para": "(vector<vector<int>> grid,int capacity)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==4);\n}"}
{"index": 472, "humaneval_task_id": "CPP/115", "focal_method_name": "max_fill", "focal_method_para": "(vector<vector<int>> grid,int capacity)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==5);\n}"}
{"index": 473, "humaneval_task_id": "CPP/115", "focal_method_name": "max_fill", "focal_method_para": "(vector<vector<int>> grid,int capacity)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==2);\n}"}
{"index": 474, "humaneval_task_id": "CPP/116", "focal_method_name": "sort_array", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{2,4,8,16,32}));\n}"}
{"index": 475, "humaneval_task_id": "CPP/116", "focal_method_name": "sort_array", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{-4,-2,-6,-5,-3}));\n}"}
{"index": 476, "humaneval_task_id": "CPP/116", "focal_method_name": "sort_array", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{1,2,4,3,5}));\n}"}
{"index": 477, "humaneval_task_id": "CPP/116", "focal_method_name": "sort_array", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 478, "humaneval_task_id": "CPP/116", "focal_method_name": "sort_array", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{32,3,5,6,12,44}));\n}"}
{"index": 479, "humaneval_task_id": "CPP/116", "focal_method_name": "sort_array", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,1,2,4,3}));\n}"}
{"index": 480, "humaneval_task_id": "CPP/116", "focal_method_name": "sort_array", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{2,2,4,4,3,3,5,5,5,7,77}));\n}"}
{"index": 481, "humaneval_task_id": "CPP/117", "focal_method_name": "select_words", "focal_method_para": "(string s,int n)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"Uncle\"}));\n}"}
{"index": 482, "humaneval_task_id": "CPP/117", "focal_method_name": "select_words", "focal_method_para": "(string s,int n)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"b\",\"c\",\"d\",\"f\"}));\n}"}
{"index": 483, "humaneval_task_id": "CPP/117", "focal_method_name": "select_words", "focal_method_para": "(string s,int n)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"world\"}));\n}"}
{"index": 484, "humaneval_task_id": "CPP/117", "focal_method_name": "select_words", "focal_method_para": "(string s,int n)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"little\"}));\n}"}
{"index": 485, "humaneval_task_id": "CPP/117", "focal_method_name": "select_words", "focal_method_para": "(string s,int n)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"Mary\",\"lamb\"}));\n}"}
{"index": 486, "humaneval_task_id": "CPP/117", "focal_method_name": "select_words", "focal_method_para": "(string s,int n)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 487, "humaneval_task_id": "CPP/118", "focal_method_name": "get_closest_vowel", "focal_method_para": "(string word)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"o\");\n}"}
{"index": 488, "humaneval_task_id": "CPP/118", "focal_method_name": "get_closest_vowel", "focal_method_para": "(string word)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"a\");\n}"}
{"index": 489, "humaneval_task_id": "CPP/118", "focal_method_name": "get_closest_vowel", "focal_method_para": "(string word)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"\");\n}"}
{"index": 490, "humaneval_task_id": "CPP/118", "focal_method_name": "get_closest_vowel", "focal_method_para": "(string word)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"u\");\n}"}
{"index": 491, "humaneval_task_id": "CPP/118", "focal_method_name": "get_closest_vowel", "focal_method_para": "(string word)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"i\");\n}"}
{"index": 492, "humaneval_task_id": "CPP/119", "focal_method_name": "match_parens", "focal_method_para": "(vector<string> lst)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring match_parens(vector<string> lst){\n    string l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = match_parens(<FILL_ME>);\n\tassert(result==\"No\");\n}"}
{"index": 493, "humaneval_task_id": "CPP/119", "focal_method_name": "match_parens", "focal_method_para": "(vector<string> lst)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring match_parens(vector<string> lst){\n    string l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = match_parens(<FILL_ME>);\n\tassert(result==\"Yes\");\n}"}
{"index": 494, "humaneval_task_id": "CPP/120", "focal_method_name": "maximum", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-13,-8,0,0,3,5,15}));\n}"}
{"index": 495, "humaneval_task_id": "CPP/120", "focal_method_name": "maximum", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{2,20,123}));\n}"}
{"index": 496, "humaneval_task_id": "CPP/120", "focal_method_name": "maximum", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{0,1,2,20}));\n}"}
{"index": 497, "humaneval_task_id": "CPP/120", "focal_method_name": "maximum", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-4,-3,5}));\n}"}
{"index": 498, "humaneval_task_id": "CPP/120", "focal_method_name": "maximum", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{4,4}));\n}"}
{"index": 499, "humaneval_task_id": "CPP/120", "focal_method_name": "maximum", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-10,10}));\n}"}
{"index": 500, "humaneval_task_id": "CPP/120", "focal_method_name": "maximum", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{2}));\n}"}
{"index": 501, "humaneval_task_id": "CPP/120", "focal_method_name": "maximum", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{3,5}));\n}"}
{"index": 502, "humaneval_task_id": "CPP/120", "focal_method_name": "maximum", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 503, "humaneval_task_id": "CPP/120", "focal_method_name": "maximum", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{5}));\n}"}
{"index": 504, "humaneval_task_id": "CPP/120", "focal_method_name": "maximum", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-4,4}));\n}"}
{"index": 505, "humaneval_task_id": "CPP/121", "focal_method_name": "solutions", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==12);\n}"}
{"index": 506, "humaneval_task_id": "CPP/121", "focal_method_name": "solutions", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 507, "humaneval_task_id": "CPP/121", "focal_method_name": "solutions", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==5);\n}"}
{"index": 508, "humaneval_task_id": "CPP/121", "focal_method_name": "solutions", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==23);\n}"}
{"index": 509, "humaneval_task_id": "CPP/121", "focal_method_name": "solutions", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==3);\n}"}
{"index": 510, "humaneval_task_id": "CPP/121", "focal_method_name": "solutions", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==9);\n}"}
{"index": 511, "humaneval_task_id": "CPP/122", "focal_method_name": "add_elements", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 512, "humaneval_task_id": "CPP/122", "focal_method_name": "add_elements", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==-4);\n}"}
{"index": 513, "humaneval_task_id": "CPP/122", "focal_method_name": "add_elements", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 514, "humaneval_task_id": "CPP/122", "focal_method_name": "add_elements", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==125);\n}"}
{"index": 515, "humaneval_task_id": "CPP/122", "focal_method_name": "add_elements", "focal_method_para": "(vector<int> arr,int k)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==24);\n}"}
{"index": 516, "humaneval_task_id": "CPP/123", "focal_method_name": "get_odd_collatz", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,3,5}));\n}"}
{"index": 517, "humaneval_task_id": "CPP/123", "focal_method_name": "get_odd_collatz", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,5}));\n}"}
{"index": 518, "humaneval_task_id": "CPP/123", "focal_method_name": "get_odd_collatz", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1}));\n}"}
{"index": 519, "humaneval_task_id": "CPP/123", "focal_method_name": "get_odd_collatz", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,5,7,11,13,17}));\n}"}
{"index": 520, "humaneval_task_id": "CPP/124", "focal_method_name": "valid_date", "focal_method_para": "(string date)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool valid_date(string date){\n    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = valid_date(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 521, "humaneval_task_id": "CPP/124", "focal_method_name": "valid_date", "focal_method_para": "(string date)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool valid_date(string date){\n    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = valid_date(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 522, "humaneval_task_id": "CPP/125", "focal_method_name": "split_words", "focal_method_para": "(string txt)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello\",\"world!\"}));\n}"}
{"index": 523, "humaneval_task_id": "CPP/125", "focal_method_name": "split_words", "focal_method_para": "(string txt)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"0\"}));\n}"}
{"index": 524, "humaneval_task_id": "CPP/125", "focal_method_name": "split_words", "focal_method_para": "(string txt)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello,Hello,world\",\"!\"}));\n}"}
{"index": 525, "humaneval_task_id": "CPP/125", "focal_method_name": "split_words", "focal_method_para": "(string txt)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"3\"}));\n}"}
{"index": 526, "humaneval_task_id": "CPP/125", "focal_method_name": "split_words", "focal_method_para": "(string txt)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"2\"}));\n}"}
{"index": 527, "humaneval_task_id": "CPP/125", "focal_method_name": "split_words", "focal_method_para": "(string txt)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"1\"}));\n}"}
{"index": 528, "humaneval_task_id": "CPP/125", "focal_method_name": "split_words", "focal_method_para": "(string txt)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello\",\"world,!\"}));\n}"}
{"index": 529, "humaneval_task_id": "CPP/126", "focal_method_name": "is_sorted", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\n    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_sorted(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 530, "humaneval_task_id": "CPP/126", "focal_method_name": "is_sorted", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\n    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_sorted(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 531, "humaneval_task_id": "CPP/127", "focal_method_name": "intersection", "focal_method_para": "( vector<int> interval1,vector<int> interval2)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring intersection( vector<int> interval1,vector<int> interval2){\n    int inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = intersection(<FILL_ME>);\n\tassert(result==\"NO\");\n}"}
{"index": 532, "humaneval_task_id": "CPP/127", "focal_method_name": "intersection", "focal_method_para": "( vector<int> interval1,vector<int> interval2)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring intersection( vector<int> interval1,vector<int> interval2){\n    int inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = intersection(<FILL_ME>);\n\tassert(result==\"YES\");\n}"}
{"index": 533, "humaneval_task_id": "CPP/128", "focal_method_name": "prod_signs", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 534, "humaneval_task_id": "CPP/128", "focal_method_name": "prod_signs", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-4);\n}"}
{"index": 535, "humaneval_task_id": "CPP/128", "focal_method_name": "prod_signs", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-10);\n}"}
{"index": 536, "humaneval_task_id": "CPP/128", "focal_method_name": "prod_signs", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-9);\n}"}
{"index": 537, "humaneval_task_id": "CPP/128", "focal_method_name": "prod_signs", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==4);\n}"}
{"index": 538, "humaneval_task_id": "CPP/128", "focal_method_name": "prod_signs", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==20);\n}"}
{"index": 539, "humaneval_task_id": "CPP/128", "focal_method_name": "prod_signs", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-32768);\n}"}
{"index": 540, "humaneval_task_id": "CPP/129", "focal_method_name": "minPath", "focal_method_para": "(vector<vector<int>> grid, int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,6,1,6,1,6,1,6,1}));\n}"}
{"index": 541, "humaneval_task_id": "CPP/129", "focal_method_name": "minPath", "focal_method_para": "(vector<vector<int>> grid, int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,5,1,5,1,5,1,5}));\n}"}
{"index": 542, "humaneval_task_id": "CPP/129", "focal_method_name": "minPath", "focal_method_para": "(vector<vector<int>> grid, int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1}));\n}"}
{"index": 543, "humaneval_task_id": "CPP/129", "focal_method_name": "minPath", "focal_method_para": "(vector<vector<int>> grid, int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,7,1,7,1}));\n}"}
{"index": 544, "humaneval_task_id": "CPP/129", "focal_method_name": "minPath", "focal_method_para": "(vector<vector<int>> grid, int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1,2,1,2,1,2,1,2}));\n}"}
{"index": 545, "humaneval_task_id": "CPP/129", "focal_method_name": "minPath", "focal_method_para": "(vector<vector<int>> grid, int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,10,1,10,1,10,1}));\n}"}
{"index": 546, "humaneval_task_id": "CPP/129", "focal_method_name": "minPath", "focal_method_para": "(vector<vector<int>> grid, int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,6,1,6,1,6,1,6,1,6,1,6}));\n}"}
{"index": 547, "humaneval_task_id": "CPP/129", "focal_method_name": "minPath", "focal_method_para": "(vector<vector<int>> grid, int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,3,1,3,1,3,1,3}));\n}"}
{"index": 548, "humaneval_task_id": "CPP/129", "focal_method_name": "minPath", "focal_method_para": "(vector<vector<int>> grid, int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,3,1,3,1,3,1,3,1,3}));\n}"}
{"index": 549, "humaneval_task_id": "CPP/129", "focal_method_name": "minPath", "focal_method_para": "(vector<vector<int>> grid, int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1}));\n}"}
{"index": 550, "humaneval_task_id": "CPP/129", "focal_method_name": "minPath", "focal_method_para": "(vector<vector<int>> grid, int k)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1,2}));\n}"}
{"index": 551, "humaneval_task_id": "CPP/130", "focal_method_name": "tri", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24}));\n}"}
{"index": 552, "humaneval_task_id": "CPP/130", "focal_method_name": "tri", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5,35}));\n}"}
{"index": 553, "humaneval_task_id": "CPP/130", "focal_method_name": "tri", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11}));\n}"}
{"index": 554, "humaneval_task_id": "CPP/130", "focal_method_name": "tri", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1}));\n}"}
{"index": 555, "humaneval_task_id": "CPP/130", "focal_method_name": "tri", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5}));\n}"}
{"index": 556, "humaneval_task_id": "CPP/130", "focal_method_name": "tri", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3}));\n}"}
{"index": 557, "humaneval_task_id": "CPP/130", "focal_method_name": "tri", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15}));\n}"}
{"index": 558, "humaneval_task_id": "CPP/130", "focal_method_name": "tri", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4}));\n}"}
{"index": 559, "humaneval_task_id": "CPP/130", "focal_method_name": "tri", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3}));\n}"}
{"index": 560, "humaneval_task_id": "CPP/130", "focal_method_name": "tri", "focal_method_para": "(int n)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8}));\n}"}
{"index": 561, "humaneval_task_id": "CPP/131", "focal_method_name": "digits", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 562, "humaneval_task_id": "CPP/131", "focal_method_name": "digits", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==2625);\n}"}
{"index": 563, "humaneval_task_id": "CPP/131", "focal_method_name": "digits", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 564, "humaneval_task_id": "CPP/131", "focal_method_name": "digits", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==315);\n}"}
{"index": 565, "humaneval_task_id": "CPP/131", "focal_method_name": "digits", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==5);\n}"}
{"index": 566, "humaneval_task_id": "CPP/132", "focal_method_name": "is_nested", "focal_method_para": "(string str)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_nested(string str){\n    int count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_nested(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 567, "humaneval_task_id": "CPP/132", "focal_method_name": "is_nested", "focal_method_para": "(string str)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_nested(string str){\n    int count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_nested(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 568, "humaneval_task_id": "CPP/133", "focal_method_name": "sum_squares", "focal_method_para": "(vector<float> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==14);\n}"}
{"index": 569, "humaneval_task_id": "CPP/133", "focal_method_name": "sum_squares", "focal_method_para": "(vector<float> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 570, "humaneval_task_id": "CPP/133", "focal_method_name": "sum_squares", "focal_method_para": "(vector<float> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==75);\n}"}
{"index": 571, "humaneval_task_id": "CPP/133", "focal_method_name": "sum_squares", "focal_method_para": "(vector<float> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 572, "humaneval_task_id": "CPP/133", "focal_method_name": "sum_squares", "focal_method_para": "(vector<float> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==6);\n}"}
{"index": 573, "humaneval_task_id": "CPP/133", "focal_method_name": "sum_squares", "focal_method_para": "(vector<float> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==29);\n}"}
{"index": 574, "humaneval_task_id": "CPP/133", "focal_method_name": "sum_squares", "focal_method_para": "(vector<float> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==10230);\n}"}
{"index": 575, "humaneval_task_id": "CPP/133", "focal_method_name": "sum_squares", "focal_method_para": "(vector<float> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==84);\n}"}
{"index": 576, "humaneval_task_id": "CPP/133", "focal_method_name": "sum_squares", "focal_method_para": "(vector<float> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==1086);\n}"}
{"index": 577, "humaneval_task_id": "CPP/133", "focal_method_name": "sum_squares", "focal_method_para": "(vector<float> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==2);\n}"}
{"index": 578, "humaneval_task_id": "CPP/133", "focal_method_name": "sum_squares", "focal_method_para": "(vector<float> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==200000000);\n}"}
{"index": 579, "humaneval_task_id": "CPP/134", "focal_method_name": "check_if_last_char_is_a_letter", "focal_method_para": "(string txt)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = check_if_last_char_is_a_letter(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 580, "humaneval_task_id": "CPP/134", "focal_method_name": "check_if_last_char_is_a_letter", "focal_method_para": "(string txt)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = check_if_last_char_is_a_letter(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 581, "humaneval_task_id": "CPP/135", "focal_method_name": "can_arrange", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==3);\n}"}
{"index": 582, "humaneval_task_id": "CPP/135", "focal_method_name": "can_arrange", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==4);\n}"}
{"index": 583, "humaneval_task_id": "CPP/135", "focal_method_name": "can_arrange", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==-1);\n}"}
{"index": 584, "humaneval_task_id": "CPP/135", "focal_method_name": "can_arrange", "focal_method_para": "(vector<int> arr)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==2);\n}"}
{"index": 585, "humaneval_task_id": "CPP/136", "focal_method_name": "largest_smallest_integers", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-1,0}));\n}"}
{"index": 586, "humaneval_task_id": "CPP/136", "focal_method_name": "largest_smallest_integers", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-3,1}));\n}"}
{"index": 587, "humaneval_task_id": "CPP/136", "focal_method_name": "largest_smallest_integers", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{0,0}));\n}"}
{"index": 588, "humaneval_task_id": "CPP/136", "focal_method_name": "largest_smallest_integers", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-7,2}));\n}"}
{"index": 589, "humaneval_task_id": "CPP/136", "focal_method_name": "largest_smallest_integers", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}"}
{"index": 590, "humaneval_task_id": "CPP/136", "focal_method_name": "largest_smallest_integers", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-9,2}));\n}"}
{"index": 591, "humaneval_task_id": "CPP/136", "focal_method_name": "largest_smallest_integers", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-2,1}));\n}"}
{"index": 592, "humaneval_task_id": "CPP/137", "focal_method_name": "compare_one", "focal_method_para": "(boost::any a,boost::any b)", "focal_method_return_type": "boost::any", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"2\");\n}"}
{"index": 593, "humaneval_task_id": "CPP/137", "focal_method_name": "compare_one", "focal_method_para": "(boost::any a,boost::any b)", "focal_method_return_type": "boost::any", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"2,3\");\n}"}
{"index": 594, "humaneval_task_id": "CPP/137", "focal_method_name": "compare_one", "focal_method_para": "(boost::any a,boost::any b)", "focal_method_return_type": "boost::any", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==3);\n}"}
{"index": 595, "humaneval_task_id": "CPP/137", "focal_method_name": "compare_one", "focal_method_para": "(boost::any a,boost::any b)", "focal_method_return_type": "boost::any", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"6\");\n}"}
{"index": 596, "humaneval_task_id": "CPP/137", "focal_method_name": "compare_one", "focal_method_para": "(boost::any a,boost::any b)", "focal_method_return_type": "boost::any", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==2);\n}"}
{"index": 597, "humaneval_task_id": "CPP/137", "focal_method_name": "compare_one", "focal_method_para": "(boost::any a,boost::any b)", "focal_method_return_type": "boost::any", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"None\");\n}"}
{"index": 598, "humaneval_task_id": "CPP/137", "focal_method_name": "compare_one", "focal_method_para": "(boost::any a,boost::any b)", "focal_method_return_type": "boost::any", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==6);\n}"}
{"index": 599, "humaneval_task_id": "CPP/137", "focal_method_name": "compare_one", "focal_method_para": "(boost::any a,boost::any b)", "focal_method_return_type": "boost::any", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<double>(result)==2.5);\n}"}
{"index": 600, "humaneval_task_id": "CPP/138", "focal_method_name": "is_equal_to_sum_even", "focal_method_para": "(int n)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n    if (n%2==0 and n>=8) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_equal_to_sum_even(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 601, "humaneval_task_id": "CPP/138", "focal_method_name": "is_equal_to_sum_even", "focal_method_para": "(int n)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n    if (n%2==0 and n>=8) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = is_equal_to_sum_even(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 602, "humaneval_task_id": "CPP/139", "focal_method_name": "special_factorial", "focal_method_para": "(int n)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 603, "humaneval_task_id": "CPP/139", "focal_method_name": "special_factorial", "focal_method_para": "(int n)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==288);\n}"}
{"index": 604, "humaneval_task_id": "CPP/139", "focal_method_name": "special_factorial", "focal_method_para": "(int n)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==125411328000);\n}"}
{"index": 605, "humaneval_task_id": "CPP/139", "focal_method_name": "special_factorial", "focal_method_para": "(int n)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==34560);\n}"}
{"index": 606, "humaneval_task_id": "CPP/140", "focal_method_name": "fix_spaces", "focal_method_para": "(string text)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Example\");\n}"}
{"index": 607, "humaneval_task_id": "CPP/140", "focal_method_name": "fix_spaces", "focal_method_para": "(string text)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Yellow_Yellow__Dirty__Fellow\");\n}"}
{"index": 608, "humaneval_task_id": "CPP/140", "focal_method_name": "fix_spaces", "focal_method_para": "(string text)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Mudasir_Hanif_\");\n}"}
{"index": 609, "humaneval_task_id": "CPP/140", "focal_method_name": "fix_spaces", "focal_method_para": "(string text)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Exa-mple\");\n}"}
{"index": 610, "humaneval_task_id": "CPP/140", "focal_method_name": "fix_spaces", "focal_method_para": "(string text)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"-Exa_1_2_2_mple\");\n}"}
{"index": 611, "humaneval_task_id": "CPP/141", "focal_method_name": "file_name_check", "focal_method_para": "(string file_name)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring file_name_check(string file_name){\n    int numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = file_name_check(<FILL_ME>);\n\tassert(result==\"No\");\n}"}
{"index": 612, "humaneval_task_id": "CPP/141", "focal_method_name": "file_name_check", "focal_method_para": "(string file_name)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring file_name_check(string file_name){\n    int numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = file_name_check(<FILL_ME>);\n\tassert(result==\"Yes\");\n}"}
{"index": 613, "humaneval_task_id": "CPP/142", "focal_method_name": "sum_squares", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==14);\n}"}
{"index": 614, "humaneval_task_id": "CPP/142", "focal_method_name": "sum_squares", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-3);\n}"}
{"index": 615, "humaneval_task_id": "CPP/142", "focal_method_name": "sum_squares", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 616, "humaneval_task_id": "CPP/142", "focal_method_name": "sum_squares", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-126);\n}"}
{"index": 617, "humaneval_task_id": "CPP/142", "focal_method_name": "sum_squares", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-1448);\n}"}
{"index": 618, "humaneval_task_id": "CPP/142", "focal_method_name": "sum_squares", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==3030);\n}"}
{"index": 619, "humaneval_task_id": "CPP/142", "focal_method_name": "sum_squares", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==6);\n}"}
{"index": 620, "humaneval_task_id": "CPP/142", "focal_method_name": "sum_squares", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-14196);\n}"}
{"index": 621, "humaneval_task_id": "CPP/142", "focal_method_name": "sum_squares", "focal_method_para": "(vector<int> lst)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==9);\n}"}
{"index": 622, "humaneval_task_id": "CPP/143", "focal_method_name": "words_in_sentence", "focal_method_para": "(string sentence)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"goforit\");\n}"}
{"index": 623, "humaneval_task_id": "CPP/143", "focal_method_name": "words_in_sentence", "focal_method_para": "(string sentence)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"thereisnoplace\");\n}"}
{"index": 624, "humaneval_task_id": "CPP/143", "focal_method_name": "words_in_sentence", "focal_method_para": "(string sentence)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"gofor\");\n}"}
{"index": 625, "humaneval_task_id": "CPP/143", "focal_method_name": "words_in_sentence", "focal_method_para": "(string sentence)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"is\");\n}"}
{"index": 626, "humaneval_task_id": "CPP/143", "focal_method_name": "words_in_sentence", "focal_method_para": "(string sentence)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"\");\n}"}
{"index": 627, "humaneval_task_id": "CPP/143", "focal_method_name": "words_in_sentence", "focal_method_para": "(string sentence)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"HiamHussein\");\n}"}
{"index": 628, "humaneval_task_id": "CPP/144", "focal_method_name": "simplify", "focal_method_para": "(string x,string n)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nbool simplify(string x,string n){\n    int a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = simplify(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 629, "humaneval_task_id": "CPP/144", "focal_method_name": "simplify", "focal_method_para": "(string x,string n)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nbool simplify(string x,string n){\n    int a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = simplify(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 630, "humaneval_task_id": "CPP/145", "focal_method_name": "order_by_points", "focal_method_para": "(vector<int> nums)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{1,10,2,11,3,4,5,6,7,8,9}));\n}"}
{"index": 631, "humaneval_task_id": "CPP/145", "focal_method_name": "order_by_points", "focal_method_para": "(vector<int> nums)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-3,-32,-98,-11,1,2,43,54}));\n}"}
{"index": 632, "humaneval_task_id": "CPP/145", "focal_method_name": "order_by_points", "focal_method_para": "(vector<int> nums)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 633, "humaneval_task_id": "CPP/145", "focal_method_name": "order_by_points", "focal_method_para": "(vector<int> nums)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457}));\n}"}
{"index": 634, "humaneval_task_id": "CPP/145", "focal_method_name": "order_by_points", "focal_method_para": "(vector<int> nums)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-76,-21,0,4,23,6,6}));\n}"}
{"index": 635, "humaneval_task_id": "CPP/145", "focal_method_name": "order_by_points", "focal_method_para": "(vector<int> nums)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-1,-11,1,-12,11}));\n}"}
{"index": 636, "humaneval_task_id": "CPP/146", "focal_method_name": "specialFilter", "focal_method_para": "(vector<int> nums)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 637, "humaneval_task_id": "CPP/146", "focal_method_name": "specialFilter", "focal_method_para": "(vector<int> nums)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 638, "humaneval_task_id": "CPP/146", "focal_method_name": "specialFilter", "focal_method_para": "(vector<int> nums)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==4);\n}"}
{"index": 639, "humaneval_task_id": "CPP/146", "focal_method_name": "specialFilter", "focal_method_para": "(vector<int> nums)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==3);\n}"}
{"index": 640, "humaneval_task_id": "CPP/146", "focal_method_name": "specialFilter", "focal_method_para": "(vector<int> nums)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==2);\n}"}
{"index": 641, "humaneval_task_id": "CPP/147", "focal_method_name": "get_matrix_triples", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==53361);\n}"}
{"index": 642, "humaneval_task_id": "CPP/147", "focal_method_name": "get_matrix_triples", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==4);\n}"}
{"index": 643, "humaneval_task_id": "CPP/147", "focal_method_name": "get_matrix_triples", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==1);\n}"}
{"index": 644, "humaneval_task_id": "CPP/147", "focal_method_name": "get_matrix_triples", "focal_method_para": "(int n)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==36);\n}"}
{"index": 645, "humaneval_task_id": "CPP/148", "focal_method_name": "bf", "focal_method_para": "(string planet1,string planet2)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\"}));\n}"}
{"index": 646, "humaneval_task_id": "CPP/148", "focal_method_name": "bf", "focal_method_para": "(string planet1,string planet2)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Saturn\",\"Uranus\"}));\n}"}
{"index": 647, "humaneval_task_id": "CPP/148", "focal_method_name": "bf", "focal_method_para": "(string planet1,string planet2)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 648, "humaneval_task_id": "CPP/148", "focal_method_name": "bf", "focal_method_para": "(string planet1,string planet2)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Venus\",}));\n}"}
{"index": 649, "humaneval_task_id": "CPP/148", "focal_method_name": "bf", "focal_method_para": "(string planet1,string planet2)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\"}));\n}"}
{"index": 650, "humaneval_task_id": "CPP/149", "focal_method_name": "sorted_list_sum", "focal_method_para": "(vector<string> lst)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"abcd\",\"dcba\"}));\n}"}
{"index": 651, "humaneval_task_id": "CPP/149", "focal_method_name": "sorted_list_sum", "focal_method_para": "(vector<string> lst)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"cc\",\"dd\",\"aaaa\",\"bbbb\"}));\n}"}
{"index": 652, "humaneval_task_id": "CPP/149", "focal_method_name": "sorted_list_sum", "focal_method_para": "(vector<string> lst)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"aa\"}));\n}"}
{"index": 653, "humaneval_task_id": "CPP/149", "focal_method_name": "sorted_list_sum", "focal_method_para": "(vector<string> lst)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"AI\",\"asdf\",\"school\"}));\n}"}
{"index": 654, "humaneval_task_id": "CPP/149", "focal_method_name": "sorted_list_sum", "focal_method_para": "(vector<string> lst)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
{"index": 655, "humaneval_task_id": "CPP/149", "focal_method_name": "sorted_list_sum", "focal_method_para": "(vector<string> lst)", "focal_method_return_type": "vector<string>", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"AI\",\"ai\",\"au\"}));\n}"}
{"index": 656, "humaneval_task_id": "CPP/150", "focal_method_name": "x_or_y", "focal_method_para": "(int n,int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 657, "humaneval_task_id": "CPP/150", "focal_method_name": "x_or_y", "focal_method_para": "(int n,int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==34);\n}"}
{"index": 658, "humaneval_task_id": "CPP/150", "focal_method_name": "x_or_y", "focal_method_para": "(int n,int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==129);\n}"}
{"index": 659, "humaneval_task_id": "CPP/150", "focal_method_name": "x_or_y", "focal_method_para": "(int n,int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==33);\n}"}
{"index": 660, "humaneval_task_id": "CPP/150", "focal_method_name": "x_or_y", "focal_method_para": "(int n,int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==-1);\n}"}
{"index": 661, "humaneval_task_id": "CPP/150", "focal_method_name": "x_or_y", "focal_method_para": "(int n,int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==1234);\n}"}
{"index": 662, "humaneval_task_id": "CPP/150", "focal_method_name": "x_or_y", "focal_method_para": "(int n,int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==3);\n}"}
{"index": 663, "humaneval_task_id": "CPP/150", "focal_method_name": "x_or_y", "focal_method_para": "(int n,int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==583);\n}"}
{"index": 664, "humaneval_task_id": "CPP/150", "focal_method_name": "x_or_y", "focal_method_para": "(int n,int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==5);\n}"}
{"index": 665, "humaneval_task_id": "CPP/150", "focal_method_name": "x_or_y", "focal_method_para": "(int n,int x,int y)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==2);\n}"}
{"index": 666, "humaneval_task_id": "CPP/151", "focal_method_name": "double_the_difference", "focal_method_para": "(vector<float> lst)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==34);\n}"}
{"index": 667, "humaneval_task_id": "CPP/151", "focal_method_name": "double_the_difference", "focal_method_para": "(vector<float> lst)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==25);\n}"}
{"index": 668, "humaneval_task_id": "CPP/151", "focal_method_name": "double_the_difference", "focal_method_para": "(vector<float> lst)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==0);\n}"}
{"index": 669, "humaneval_task_id": "CPP/151", "focal_method_name": "double_the_difference", "focal_method_para": "(vector<float> lst)", "focal_method_return_type": "long long", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==odd_sum);\n}"}
{"index": 670, "humaneval_task_id": "CPP/152", "focal_method_name": "compare", "focal_method_para": "(vector<int> game,vector<int> guess)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{0,0,0,0,3,3}));\n}"}
{"index": 671, "humaneval_task_id": "CPP/152", "focal_method_name": "compare", "focal_method_para": "(vector<int> game,vector<int> guess)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{2,4,6}));\n}"}
{"index": 672, "humaneval_task_id": "CPP/152", "focal_method_name": "compare", "focal_method_para": "(vector<int> game,vector<int> guess)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{4,4,1,0,0,6}));\n}"}
{"index": 673, "humaneval_task_id": "CPP/152", "focal_method_name": "compare", "focal_method_para": "(vector<int> game,vector<int> guess)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{2,0,0,1}));\n}"}
{"index": 674, "humaneval_task_id": "CPP/152", "focal_method_name": "compare", "focal_method_para": "(vector<int> game,vector<int> guess)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{0,0,0,0,0,0}));\n}"}
{"index": 675, "humaneval_task_id": "CPP/153", "focal_method_name": "Strongest_Extension", "focal_method_para": "(string class_name,vector<string> extensions)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Boku123.YEs.WeCaNe\");\n}"}
{"index": 676, "humaneval_task_id": "CPP/153", "focal_method_name": "Strongest_Extension", "focal_method_para": "(string class_name,vector<string> extensions)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"finNNalLLly.WoW\");\n}"}
{"index": 677, "humaneval_task_id": "CPP/153", "focal_method_name": "Strongest_Extension", "focal_method_para": "(string class_name,vector<string> extensions)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"__HAHA.123\");\n}"}
{"index": 678, "humaneval_task_id": "CPP/153", "focal_method_name": "Strongest_Extension", "focal_method_para": "(string class_name,vector<string> extensions)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"K.TAR\");\n}"}
{"index": 679, "humaneval_task_id": "CPP/153", "focal_method_name": "Strongest_Extension", "focal_method_para": "(string class_name,vector<string> extensions)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Sp.671235\");\n}"}
{"index": 680, "humaneval_task_id": "CPP/153", "focal_method_name": "Strongest_Extension", "focal_method_para": "(string class_name,vector<string> extensions)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"__YESIMHERE.NuLl__\");\n}"}
{"index": 681, "humaneval_task_id": "CPP/153", "focal_method_name": "Strongest_Extension", "focal_method_para": "(string class_name,vector<string> extensions)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"YameRore.okIWILL123\");\n}"}
{"index": 682, "humaneval_task_id": "CPP/153", "focal_method_name": "Strongest_Extension", "focal_method_para": "(string class_name,vector<string> extensions)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"_.Bb\");\n}"}
{"index": 683, "humaneval_task_id": "CPP/153", "focal_method_name": "Strongest_Extension", "focal_method_para": "(string class_name,vector<string> extensions)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Watashi.eIGHt8OKe\");\n}"}
{"index": 684, "humaneval_task_id": "CPP/154", "focal_method_name": "cycpattern_check", "focal_method_para": "(string a,string b)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool cycpattern_check(string a,string b){\n    for (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = cycpattern_check(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 685, "humaneval_task_id": "CPP/154", "focal_method_name": "cycpattern_check", "focal_method_para": "(string a,string b)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool cycpattern_check(string a,string b){\n    for (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = cycpattern_check(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 686, "humaneval_task_id": "CPP/155", "focal_method_name": "even_odd_count", "focal_method_para": "(int num)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{1,0}));\n}"}
{"index": 687, "humaneval_task_id": "CPP/155", "focal_method_name": "even_odd_count", "focal_method_para": "(int num)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{1,1}));\n}"}
{"index": 688, "humaneval_task_id": "CPP/155", "focal_method_name": "even_odd_count", "focal_method_para": "(int num)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{3,3}));\n}"}
{"index": 689, "humaneval_task_id": "CPP/155", "focal_method_name": "even_odd_count", "focal_method_para": "(int num)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}"}
{"index": 690, "humaneval_task_id": "CPP/155", "focal_method_name": "even_odd_count", "focal_method_para": "(int num)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}"}
{"index": 691, "humaneval_task_id": "CPP/155", "focal_method_name": "even_odd_count", "focal_method_para": "(int num)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}"}
{"index": 692, "humaneval_task_id": "CPP/156", "focal_method_name": "int_to_mini_romank", "focal_method_para": "(int number)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"clii\");\n}"}
{"index": 693, "humaneval_task_id": "CPP/156", "focal_method_name": "int_to_mini_romank", "focal_method_para": "(int number)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"dxxxii\");\n}"}
{"index": 694, "humaneval_task_id": "CPP/156", "focal_method_name": "int_to_mini_romank", "focal_method_para": "(int number)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"m\");\n}"}
{"index": 695, "humaneval_task_id": "CPP/156", "focal_method_name": "int_to_mini_romank", "focal_method_para": "(int number)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xix\");\n}"}
{"index": 696, "humaneval_task_id": "CPP/156", "focal_method_name": "int_to_mini_romank", "focal_method_para": "(int number)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xciv\");\n}"}
{"index": 697, "humaneval_task_id": "CPP/156", "focal_method_name": "int_to_mini_romank", "focal_method_para": "(int number)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cm\");\n}"}
{"index": 698, "humaneval_task_id": "CPP/156", "focal_method_name": "int_to_mini_romank", "focal_method_para": "(int number)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cmxciv\");\n}"}
{"index": 699, "humaneval_task_id": "CPP/156", "focal_method_name": "int_to_mini_romank", "focal_method_para": "(int number)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"ccli\");\n}"}
{"index": 700, "humaneval_task_id": "CPP/156", "focal_method_name": "int_to_mini_romank", "focal_method_para": "(int number)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xc\");\n}"}
{"index": 701, "humaneval_task_id": "CPP/156", "focal_method_name": "int_to_mini_romank", "focal_method_para": "(int number)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cdxxvi\");\n}"}
{"index": 702, "humaneval_task_id": "CPP/156", "focal_method_name": "int_to_mini_romank", "focal_method_para": "(int number)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"iv\");\n}"}
{"index": 703, "humaneval_task_id": "CPP/156", "focal_method_name": "int_to_mini_romank", "focal_method_para": "(int number)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"d\");\n}"}
{"index": 704, "humaneval_task_id": "CPP/156", "focal_method_name": "int_to_mini_romank", "focal_method_para": "(int number)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"i\");\n}"}
{"index": 705, "humaneval_task_id": "CPP/156", "focal_method_name": "int_to_mini_romank", "focal_method_para": "(int number)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xliii\");\n}"}
{"index": 706, "humaneval_task_id": "CPP/157", "focal_method_name": "right_angle_triangle", "focal_method_para": "(float a,float b,float c)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool right_angle_triangle(float a,float b,float c){\n    if (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = right_angle_triangle(<FILL_ME>);\n\tassert(result==false);\n}"}
{"index": 707, "humaneval_task_id": "CPP/157", "focal_method_name": "right_angle_triangle", "focal_method_para": "(float a,float b,float c)", "focal_method_return_type": "bool", "focal_method": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool right_angle_triangle(float a,float b,float c){\n    if (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = right_angle_triangle(<FILL_ME>);\n\tassert(result==true);\n}"}
{"index": 708, "humaneval_task_id": "CPP/158", "focal_method_name": "find_max", "focal_method_para": "(vector<string> words)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"nation\"));\n}"}
{"index": 709, "humaneval_task_id": "CPP/158", "focal_method_name": "find_max", "focal_method_para": "(vector<string> words)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"enam\"));\n}"}
{"index": 710, "humaneval_task_id": "CPP/158", "focal_method_name": "find_max", "focal_method_para": "(vector<string> words)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"play\"));\n}"}
{"index": 711, "humaneval_task_id": "CPP/158", "focal_method_name": "find_max", "focal_method_para": "(vector<string> words)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"aaaaaaa\"));\n}"}
{"index": 712, "humaneval_task_id": "CPP/158", "focal_method_name": "find_max", "focal_method_para": "(vector<string> words)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"this\"));\n}"}
{"index": 713, "humaneval_task_id": "CPP/158", "focal_method_name": "find_max", "focal_method_para": "(vector<string> words)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"abc\"));\n}"}
{"index": 714, "humaneval_task_id": "CPP/158", "focal_method_name": "find_max", "focal_method_para": "(vector<string> words)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"footbott\"));\n}"}
{"index": 715, "humaneval_task_id": "CPP/158", "focal_method_name": "find_max", "focal_method_para": "(vector<string> words)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"string\"));\n}"}
{"index": 716, "humaneval_task_id": "CPP/158", "focal_method_name": "find_max", "focal_method_para": "(vector<string> words)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"b\"));\n}"}
{"index": 717, "humaneval_task_id": "CPP/158", "focal_method_name": "find_max", "focal_method_para": "(vector<string> words)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"gonna\"));\n}"}
{"index": 718, "humaneval_task_id": "CPP/159", "focal_method_name": "eat", "focal_method_para": "(int number,int need,int remaining)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{12,1}));\n}"}
{"index": 719, "humaneval_task_id": "CPP/159", "focal_method_name": "eat", "focal_method_para": "(int number,int need,int remaining)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{5,0}));\n}"}
{"index": 720, "humaneval_task_id": "CPP/159", "focal_method_name": "eat", "focal_method_para": "(int number,int need,int remaining)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{11,0}));\n}"}
{"index": 721, "humaneval_task_id": "CPP/159", "focal_method_name": "eat", "focal_method_para": "(int number,int need,int remaining)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{7,0}));\n}"}
{"index": 722, "humaneval_task_id": "CPP/159", "focal_method_name": "eat", "focal_method_para": "(int number,int need,int remaining)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{11,4}));\n}"}
{"index": 723, "humaneval_task_id": "CPP/159", "focal_method_name": "eat", "focal_method_para": "(int number,int need,int remaining)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{9,2}));\n}"}
{"index": 724, "humaneval_task_id": "CPP/160", "focal_method_name": "do_algebra", "focal_method_para": "(vector<string> operato, vector<int> operand)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==8);\n}"}
{"index": 725, "humaneval_task_id": "CPP/160", "focal_method_name": "do_algebra", "focal_method_para": "(vector<string> operato, vector<int> operand)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==9);\n}"}
{"index": 726, "humaneval_task_id": "CPP/160", "focal_method_name": "do_algebra", "focal_method_para": "(vector<string> operato, vector<int> operand)", "focal_method_return_type": "int", "focal_method": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==37);\n}"}
{"index": 727, "humaneval_task_id": "CPP/161", "focal_method_name": "solve", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"2@6#\");\n}"}
{"index": 728, "humaneval_task_id": "CPP/161", "focal_method_name": "solve", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"aSdF\");\n}"}
{"index": 729, "humaneval_task_id": "CPP/161", "focal_method_name": "solve", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#CCC\");\n}"}
{"index": 730, "humaneval_task_id": "CPP/161", "focal_method_name": "solve", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"4321\");\n}"}
{"index": 731, "humaneval_task_id": "CPP/161", "focal_method_name": "solve", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#A@c\");\n}"}
{"index": 732, "humaneval_task_id": "CPP/161", "focal_method_name": "solve", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#aSDFw^45\");\n}"}
{"index": 733, "humaneval_task_id": "CPP/161", "focal_method_name": "solve", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#$A^d\");\n}"}
{"index": 734, "humaneval_task_id": "CPP/161", "focal_method_name": "solve", "focal_method_para": "(string s)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"AB\");\n}"}
{"index": 735, "humaneval_task_id": "CPP/162", "focal_method_name": "string_to_md5", "focal_method_para": "(string text)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"0ef78513b0cb8cef12743f5aeb35f888\");\n}"}
{"index": 736, "humaneval_task_id": "CPP/162", "focal_method_name": "string_to_md5", "focal_method_para": "(string text)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"3e25960a79dbc69b674cd4ec67a72c62\");\n}"}
{"index": 737, "humaneval_task_id": "CPP/162", "focal_method_name": "string_to_md5", "focal_method_para": "(string text)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"5f4dcc3b5aa765d61d8327deb882cf99\");\n}"}
{"index": 738, "humaneval_task_id": "CPP/162", "focal_method_name": "string_to_md5", "focal_method_para": "(string text)", "focal_method_return_type": "string", "focal_method": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}", "target": "#undef NDEBUG\n#include<assert.h>\n\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"None\");\n}"}
{"index": 739, "humaneval_task_id": "CPP/163", "focal_method_name": "generate_integers", "focal_method_para": "(int a,int b)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n    int m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = generate_integers(<FILL_ME>);\n\tassert(issame(result,{2,4,6,8}));\n}"}
{"index": 740, "humaneval_task_id": "CPP/163", "focal_method_name": "generate_integers", "focal_method_para": "(int a,int b)", "focal_method_return_type": "vector<int>", "focal_method": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n    int m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}", "target": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main(){\n\tauto result = generate_integers(<FILL_ME>);\n\tassert(issame(result,{}));\n}"}
